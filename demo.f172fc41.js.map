{"version":3,"sources":["webpack:///demo.f172fc41.js","webpack:///./demo/src/App.js?cc05","webpack:///./~/localforage/dist/localforage.js","webpack:///./~/preact-smitty/dist/preact-smitty.js","webpack:///./~/preact/dist/preact.js","webpack:///(webpack)/buildin/global.js","webpack:///./demo/src/index.js","webpack:///./demo/src/App.js","webpack:///./src/index.js","webpack:///./~/mitt/dist/mitt.js"],"names":["webpackJsonp","+iyJ","module","exports","0","__webpack_require__","22C0","global","require","f","e","t","n","r","s","o","u","a","i","Error","code","l","call","length","1","_dereq_","nextTick","draining","oldQueue","len","queue","immediate","task","push","scheduleDrain","Mutation","MutationObserver","WebKitMutationObserver","called","observer","element","document","createTextNode","observe","characterData","data","setImmediate","MessageChannel","createElement","scriptEl","onreadystatechange","parentNode","removeChild","documentElement","appendChild","setTimeout","channel","port1","onmessage","port2","postMessage","this","self","window","2","INTERNAL","Promise","resolver","TypeError","state","PENDING","outcome","safelyResolveThenable","QueueItem","promise","onFulfilled","onRejected","callFulfilled","otherCallFulfilled","callRejected","otherCallRejected","unwrap","func","value","returnValue","handlers","reject","resolve","getThen","obj","then","apply","arguments","thenable","onError","onSuccess","tryToUnwrap","result","tryCatch","status","out","reason","all","iterable","allResolver","resolveFromAll","outValue","values","resolved","error","toString","Array","race","response","REJECTED","FULFILLED","prototype","constructor","3","4","_classCallCheck","instance","Constructor","getIDB","indexedDB","webkitIndexedDB","mozIndexedDB","OIndexedDB","msIndexedDB","isIndexedDBValid","idb","isSafari","openDatabase","test","navigator","userAgent","platform","hasFetch","fetch","indexOf","IDBKeyRange","isWebSQLValid","isLocalStorageValid","localStorage","setItem","createBlob","parts","properties","Blob","name","Builder","BlobBuilder","MSBlobBuilder","MozBlobBuilder","WebKitBlobBuilder","builder","append","getBlob","type","executeCallback","callback","executeTwoCallbacks","errorCallback","_binStringToArrayBuffer","bin","buf","ArrayBuffer","arr","Uint8Array","charCodeAt","_checkBlobSupportWithoutCaching","Promise$1","txn","transaction","DETECT_BLOB_SUPPORT_STORE","blob","objectStore","put","onabort","preventDefault","stopPropagation","oncomplete","matchedChrome","match","parseInt","_checkBlobSupport","supportsBlobs","_deferReadiness","dbInfo","dbContext","dbContexts","deferredOperation","deferredOperations","dbReady","_advanceReadiness","pop","_getConnection","upgradeNeeded","db","close","dbArgs","version","openreq","open","onupgradeneeded","createObjectStore","storeName","oldVersion","ex","onerror","onsuccess","_getOriginalConnection","_getUpgradedConnection","_isUpgradeNeeded","defaultVersion","isNewStore","objectStoreNames","contains","isDowngrade","isUpgrade","incVersion","_encodeBlob","reader","FileReader","onloadend","__local_forage_encoded_blob","btoa","target","readAsBinaryString","_decodeBlob","encodedBlob","atob","_isEncodedBlob","_fullyReady","_initReady","_dbInfo","_initStorage","options","ignoreErrors","forages","ready","initPromises","j","forage","slice","_defaultConfig","k","getItem","key","String","store","req","get","undefined","iterate","iterator","openCursor","iterationNumber","cursor","blobSupport","removeItem","clear","count","advanced","advance","keys","stringToBuffer","serializedString","encoded1","encoded2","encoded3","encoded4","bufferLength","p","buffer","bytes","BASE_CHARS","bufferToString","base64String","substring","serialize","valueType","toString$1","marker","SERIALIZED_MARKER","TYPE_ARRAYBUFFER","TYPE_INT8ARRAY","TYPE_UINT8ARRAY","TYPE_UINT8CLAMPEDARRAY","TYPE_INT16ARRAY","TYPE_UINT16ARRAY","TYPE_INT32ARRAY","TYPE_UINT32ARRAY","TYPE_FLOAT32ARRAY","TYPE_FLOAT64ARRAY","fileReader","onload","TYPE_BLOB","BLOB_TYPE_PREFIX","readAsArrayBuffer","JSON","stringify","deserialize","SERIALIZED_MARKER_LENGTH","parse","blobType","TYPE_SERIALIZED_MARKER_LENGTH","BLOB_TYPE_PREFIX_REGEX","matcher","Int8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","_initStorage$1","dbInfoPromise","description","size","executeSql","serializer","localforageSerializer","getItem$1","results","rows","item","iterate$1","_setItem","retriesLeft","originalValue","sqlError","QUOTA_ERR","setItem$1","removeItem$1","clear$1","length$1","c","key$1","keys$1","_initStorage$2","keyPrefix","clear$2","getItem$2","iterate$2","keyPrefixLength","key$2","keys$2","length$2","removeItem$2","setItem$2","callWhenReady","localForageInstance","libraryMethod","_args","extend","arg","hasOwnProperty","isArray","isLibraryDriver","driverName","driver","DriverType","_typeof","Symbol","asyncStorage","_driver","webSQLStorage","localStorageWrapper","CustomDrivers","INDEXEDDB","LOCALSTORAGE","WEBSQL","DefaultDriverOrder","LibraryMethods","DefaultConfig","driverSupport","LocalForage","_config","_driverSet","_initDriver","_ready","_wrapLibraryMethodsWithReady","setDriver","config","replace","defineDriver","driverObject","complianceError","namingError","customDriverMethods","concat","customDriverMethod","supportPromise","_support","supportResult","getDriver","getDriverPromise","getSerializer","serializerPromise","drivers","setDriverToConfig","extendSelfWithDriver","_extend","initDriver","supportedDrivers","driverPromiseLoop","currentDriverIndex","_getSupportedDrivers","oldDriverSetDone","supports","libraryMethodsAndProperties","createInstance","localforage_js","97Jz","handleStoreUpdate","updateAnimId","setState","props","context","on","__proto__","Object","create","componentWillUnmount","clearTimeout","off","render","h","assign","emit","Component","defineProperty","getChildContext","children","Provider","connect","EF6w","factory","VNode","nodeName","attributes","lastSimple","child","simple","stack","EMPTY_CHILDREN","vnode","clone","delve","split","isFunction","isString","hashToClassName","str","prop","cloneElement","createLinkedState","component","eventPath","path","v","checked","enqueueRender","_dirty","items","debounceRendering","defer","rerender","list","renderComponent","isFunctionalComponent","buildFunctionalComponent","getNodeProps","EMPTY","isSameNodeType","node","Text","_componentConstructor","isNamedNode","normalizedNodeName","toLowerCase","defaultProps","removeNode","setAccessor","old","isSvg","style","cssText","NON_DIMENSION_PROPS","innerHTML","__html","_listeners","addEventListener","eventProxy","NON_BUBBLING_EVENTS","removeEventListener","setProperty","removeAttribute","ns","removeAttributeNS","setAttributeNS","setAttribute","className","event","collectNode","Element","_component","_name","nodes","createNode","createElementNS","flushMounts","mounts","afterMount","componentDidMount","diff","dom","mountAll","parent","componentRoot","diffLevel","isSvgMode","ownerSVGElement","hydrating","ATTR_KEY","ret","idiff","ref","nodeValue","recollectNodeTree","buildComponentFromVNode","prevSvgMode","vchildren","firstChild","replaceChild","fc","nextSibling","innerDiffNode","dangerouslySetInnerHTML","diffAttributes","absorb","vchild","originalChildren","childNodes","keyed","keyedLen","min","childrenLen","vlen","_child","__key","insertBefore","unmountOnly","unmountComponent","lastChild","attrs","collectComponent","components","createComponent","Ctor","inst","nextBase","splice","setComponentProps","opts","_disable","__ref","base","componentWillMount","componentWillReceiveProps","prevContext","prevProps","syncComponentUpdates","isChild","skip","rendered","cbase","previousProps","previousState","prevState","previousContext","isUpdate","initialBase","initialChildComponent","shouldComponentUpdate","componentWillUpdate","toUnmount","childComponent","childProps","_parentComponent","baseParent","componentRef","unshift","componentDidUpdate","afterUpdate","fn","cb","_renderCallbacks","originalComponent","oldDom","isDirectOwner","isOwner","remove","beforeUnmount","inner","componentDidUnmount","merge","lcCache","for","boxFlex","boxFlexGroup","columnCount","fillOpacity","flex","flexGrow","flexPositive","flexShrink","flexNegative","fontWeight","lineClamp","lineHeight","opacity","order","orphans","strokeOpacity","widows","zIndex","zoom","blur","focus","load","resize","scroll","linkState","_linkedStates","forceUpdate","NNls","b+29","g","Function","eval","ctQG","__webpack_exports__","run","Root","default","root","__WEBPACK_IMPORTED_MODULE_0_preact__","querySelector","jFIt","_possibleConstructorReturn","ReferenceError","_inherits","subClass","superClass","enumerable","writable","configurable","setPrototypeOf","_asyncToGenerator","gen","step","info","done","err","Image","_ref5","image","index","onClick","selected","wrapperStyles","position","top","left","right","bottom","width","height","display","alignItems","justifyContent","background","paddingTop","paddingRight","paddingBottom","paddingLeft","imgStyles","maxHeight","borderRadius","__WEBPACK_IMPORTED_MODULE_1_preact__","href","url","src","GithubRibbon","frameborder","scrolling","marginLeft","_store$handleActions","__WEBPACK_IMPORTED_MODULE_0__style_css__","__WEBPACK_IMPORTED_MODULE_2_preact_smitty__","__WEBPACK_IMPORTED_MODULE_3__src__","__WEBPACK_IMPORTED_MODULE_4_raw_loader_App_js__","__WEBPACK_IMPORTED_MODULE_5_localforage__","__WEBPACK_IMPORTED_MODULE_5_localforage___default","_this","getId","Date","camera","recording","stream","MediaStream","images","ui","selectedImageId","createActions","startMediaStream","constraints","_ref","regeneratorRuntime","mark","_callee","wrap","_context","prev","next","mediaDevices","getUserMedia","sent","actions","mediaStreamSuccess","t0","mediaStreamError","stop","_x","addImages","saveImage","id","catch","selectImage","setSelectedImageById","history","pushState","handleActions","streamError","imageId","location","pathname","decodeURI","onpopstate","Camera","_Component","_temp","_this2","_ret","_len","args","_key","video","canvas","handleClick","ctx","getContext","videoWidth","videoHeight","fillRect","drawImage","toDataURL","audio","_ref2","_this3","marginBottom","textAlign","color","transition","URL","createObjectURL","autoplay","muted","marginTop","margin","fontSize","border","outline","boxShadow","disabled","ImageList","_ref3","_ref4","flexFlow","map","App","_ref6","overflow","WebkitOverflowScrolling","borderLeft","borderBottom","lVK7","Store","initialState","_state","events","__WEBPACK_IMPORTED_MODULE_0_mitt___default","bind","set","createStore","__WEBPACK_IMPORTED_MODULE_0_mitt__","payload","actionMap","_loop","creatorName","actionCreator","handlerMap","_loop2","handler","eventType","tNdy"],"mappings":"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","file":"demo.f172fc41.js","sourcesContent":["webpackJsonp([0,1],{\n\n/***/ \"+iyJ\":\n/***/ (function(module, exports) {\n\nmodule.exports = \"var _this = this,\\n    _store$handleActions;\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\\\"next\\\", value); }, function (err) { step(\\\"throw\\\", err); }); } } return step(\\\"next\\\"); }); }; }\\n\\n/** @jsx h */\\nimport './style.css';\\nimport { render, h, Component } from 'preact';\\nimport { Provider, connect } from 'preact-smitty';\\nimport { createStore } from '../../src';\\nimport source from 'raw-loader!./App.js';\\nimport localforage from 'localforage';\\n\\nlocalforage.config({ name: 'smitty_photo_booth' });\\n\\nvar pp = function pp(obj) {\\n  return JSON.stringify(obj, null, 2);\\n};\\nvar getId = function getId() {\\n  return new Date().toString();\\n};\\n\\nvar store = createStore({\\n  camera: {\\n    recording: false,\\n    stream: new window.MediaStream(),\\n    images: []\\n  },\\n  ui: {\\n    selectedImageId: null\\n  }\\n});\\n\\nstore.createActions({\\n  startMediaStream: function startMediaStream(constraints) {\\n    return function () {\\n      var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(store) {\\n        var stream;\\n        return regeneratorRuntime.wrap(function _callee$(_context) {\\n          while (1) {\\n            switch (_context.prev = _context.next) {\\n              case 0:\\n                _context.prev = 0;\\n                _context.next = 3;\\n                return navigator.mediaDevices.getUserMedia(constraints);\\n\\n              case 3:\\n                stream = _context.sent;\\n\\n                store.actions.mediaStreamSuccess(stream);\\n                _context.next = 10;\\n                break;\\n\\n              case 7:\\n                _context.prev = 7;\\n                _context.t0 = _context['catch'](0);\\n\\n                store.actions.mediaStreamError(_context.t0);\\n\\n              case 10:\\n              case 'end':\\n                return _context.stop();\\n            }\\n          }\\n        }, _callee, _this, [[0, 7]]);\\n      }));\\n\\n      return function (_x) {\\n        return _ref.apply(this, arguments);\\n      };\\n    }();\\n  },\\n  mediaStreamSuccess: 'camera/STREAM_SUCCESS',\\n  mediaStreamError: 'camera/STREAM_ERROR',\\n  addImages: 'camera/ADD_IMAGES',\\n  saveImage: function saveImage(url) {\\n    return function (store) {\\n      var id = getId();\\n      var image = { id: id, url: url };\\n      store.actions.addImages([image]);\\n\\n      localforage.getItem('images').then(function (images) {\\n        images.push(image);\\n        localforage.setItem('images', images);\\n      }).catch(function (err) {\\n        return console.log('Could not save image to db', err);\\n      });\\n    };\\n  },\\n  selectImage: function selectImage(id) {\\n    return function (store) {\\n      store.actions.setSelectedImageById(id);\\n      window.history.pushState({}, '', id || '/');\\n    };\\n  },\\n  setSelectedImageById: 'ui/SELECT_IMAGE'\\n});\\n\\nstore.handleActions((_store$handleActions = {}, _store$handleActions[store.actions.mediaStreamSuccess] = function (state, stream) {\\n  state.camera.stream = stream;\\n}, _store$handleActions[store.actions.mediaStreamError] = function (state, error) {\\n  state.camera.streamError = error;\\n}, _store$handleActions[store.actions.addImages] = function (state, images) {\\n  state.camera.images = state.camera.images.concat(images);\\n}, _store$handleActions[store.actions.setSelectedImageById] = function (state, imageId) {\\n  state.ui.selectedImageId = imageId;\\n}, _store$handleActions));\\n\\nlocalforage.getItem('images').then(function (images) {\\n  if (images) {\\n    store.actions.addImages(images);\\n  } else {\\n    localforage.setItem('images', []);\\n  }\\n});\\n\\nif (window.location.pathname !== '/') {\\n  store.actions.setSelectedImageById(decodeURI(window.location.pathname).split('/')[1]);\\n}\\n\\nwindow.onpopstate = function (event) {\\n  store.actions.setSelectedImageById(decodeURI(window.location.pathname).split('/')[1]);\\n};\\n\\nvar Camera = connect(function (state) {\\n  return {\\n    stream: state.camera.stream,\\n    streamError: state.camera.streamError\\n  };\\n})(function (_Component) {\\n  _inherits(Camera, _Component);\\n\\n  function Camera() {\\n    var _temp, _this2, _ret;\\n\\n    _classCallCheck(this, Camera);\\n\\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\\n      args[_key] = arguments[_key];\\n    }\\n\\n    return _ret = (_temp = (_this2 = _possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this2), _this2.video = null, _this2.canvas = null, _this2.handleClick = function () {\\n      var canvas = _this2.canvas;\\n      var ctx = canvas.getContext('2d');\\n      var width = _this2.video.videoWidth;\\n      var height = _this2.video.videoHeight;\\n      canvas.width = width;\\n      canvas.height = height;\\n      ctx.fillRect(0, 0, width, height);\\n      ctx.drawImage(_this2.video, 0, 0, width, height);\\n\\n      _this2.context.store.actions.saveImage(canvas.toDataURL('image/webp'));\\n    }, _temp), _possibleConstructorReturn(_this2, _ret);\\n  }\\n\\n  Camera.prototype.componentDidMount = function componentDidMount() {\\n    this.context.store.actions.startMediaStream({\\n      audio: false,\\n      video: true\\n    });\\n  };\\n\\n  Camera.prototype.render = function render(_ref2) {\\n    var _this3 = this;\\n\\n    var streamError = _ref2.streamError;\\n\\n    return h(\\n      'div',\\n      {\\n        style: {\\n          paddingTop: 16,\\n          paddingRight: 16,\\n          paddingBottom: 16,\\n          paddingLeft: 16\\n        }\\n      },\\n      h(\\n        'h3',\\n        {\\n          style: {\\n            height: streamError ? 24 : 0,\\n            lineHeight: '1.2',\\n            marginBottom: 16,\\n            textAlign: 'center',\\n            color: '#ff6b6b',\\n            opacity: streamError ? 1 : 0,\\n            transition: 'all 250ms ease-in-out'\\n          }\\n        },\\n        streamError ? streamError.name : ''\\n      ),\\n      h('video', {\\n        ref: function ref(node) {\\n          _this3.video = node;\\n        },\\n        style: {\\n          width: '100%',\\n          maxHeight: 'calc(50vh - 16px)',\\n          background: '#212529',\\n          cursor: 'pointer'\\n        },\\n        src: window.URL ? window.URL.createObjectURL(this.props.stream) : this.props.stream,\\n        autoplay: true,\\n        muted: true,\\n        onClick: this.handleClick\\n      }),\\n      h('canvas', {\\n        ref: function ref(node) {\\n          _this3.canvas = node;\\n        },\\n        style: { display: 'none' }\\n      }),\\n      h(\\n        'div',\\n        {\\n          style: {\\n            display: 'flex',\\n            alignItems: 'center',\\n            justifyContent: 'center',\\n            width: '100%',\\n            marginTop: 16,\\n            marginBottom: 16\\n          }\\n        },\\n        h(\\n          'button',\\n          {\\n            style: {\\n              paddingTop: 8,\\n              paddingRight: 16,\\n              paddingBottom: 8,\\n              paddingLeft: 16,\\n              margin: '0 auto',\\n              fontSize: 20,\\n              lineHeight: '1.6',\\n              color: '#adb5bd',\\n              background: '#343a40',\\n              border: 'none',\\n              outline: 'none',\\n              boxShadow: 'none',\\n              borderRadius: 5,\\n              cursor: 'pointer',\\n              opacity: streamError ? 0 : 1,\\n              transition: 'all 250ms ease-in-out'\\n            },\\n            disabled: streamError,\\n            type: 'button',\\n            onClick: this.handleClick\\n          },\\n          'Take Picture'\\n        )\\n      )\\n    );\\n  };\\n\\n  return Camera;\\n}(Component));\\n\\nvar ImageList = connect(function (state) {\\n  return {\\n    images: state.camera.images,\\n    selectedImageId: state.ui.selectedImageId\\n  };\\n})(function ImageList(_ref3, _ref4) {\\n  var images = _ref3.images,\\n      selectedImageId = _ref3.selectedImageId;\\n  var store = _ref4.store;\\n\\n  return h(\\n    'div',\\n    {\\n      style: {\\n        display: 'flex',\\n        flexFlow: 'wrap'\\n      }\\n    },\\n    images.map(function (image, i) {\\n      return h(Image, {\\n        key: image.id,\\n        image: image,\\n        index: i,\\n        selected: image.id === selectedImageId,\\n        onClick: function onClick() {\\n          store.actions.selectImage(image.id === selectedImageId ? null : image.id);\\n        }\\n      });\\n    })\\n  );\\n});\\n\\nfunction Image(_ref5) {\\n  var image = _ref5.image,\\n      index = _ref5.index,\\n      _onClick = _ref5.onClick,\\n      selected = _ref5.selected;\\n\\n  var wrapperStyles = selected ? {\\n    position: 'fixed',\\n    top: 0,\\n    left: 0,\\n    right: 0,\\n    bottom: 0,\\n    width: '100%',\\n    height: '100%',\\n    display: 'flex',\\n    alignItems: 'center',\\n    justifyContent: 'center',\\n    background: '#f8f9fa',\\n    zIndex: 10\\n  } : {\\n    position: 'relative',\\n    flex: '0 1 auto',\\n    width: 'calc(33% - 4px)',\\n    order: index * -1,\\n    paddingTop: 2,\\n    paddingRight: 2,\\n    paddingBottom: 0,\\n    paddingLeft: 2\\n  };\\n\\n  var imgStyles = selected ? { width: '90%', maxHeight: '90%', borderRadius: 8 } : { width: '100%', borderRadius: 4 };\\n\\n  return h(\\n    'a',\\n    {\\n      style: wrapperStyles,\\n      href: image.url,\\n      target: '_blank',\\n      onClick: function onClick(e) {\\n        e.preventDefault();\\n        _onClick();\\n      }\\n    },\\n    h('img', { src: image.url, style: imgStyles })\\n  );\\n}\\n\\nfunction GithubRibbon() {\\n  return h('iframe', {\\n    src: 'https://ghbtns.com/github-btn.html?user=tkh44&repo=smitty&type=star&count=true&size=large',\\n    frameborder: '0',\\n    scrolling: '0',\\n    width: '160px',\\n    height: '30px',\\n    style: { marginLeft: 'auto' }\\n  });\\n}\\n\\nvar App = connect(function (state) {\\n  return state;\\n})(function (props) {\\n  var _ref6;\\n\\n  return h(\\n    'div',\\n    { style: { display: 'flex' } },\\n    h(\\n      'div',\\n      {\\n        style: (_ref6 = {\\n          flex: '1 0 50%',\\n          height: '100vh',\\n          background: '#212529',\\n          overflow: 'auto',\\n          WebkitOverflowScrolling: 'touch'\\n        }, _ref6['background'] = props.camera.streamError ? '#f8f9fa' : '#212529', _ref6.cursor = 'pointer', _ref6.transition = 'all 250ms ease-in-out', _ref6)\\n      },\\n      h(Camera, null)\\n    ),\\n    h(\\n      'div',\\n      {\\n        style: {\\n          flex: '1 0 50%',\\n          height: '100vh',\\n          background: '#f8f9fa',\\n          borderLeft: '1px solid #dee2e6',\\n          overflow: 'auto',\\n          WebkitOverflowScrolling: 'touch'\\n        }\\n      },\\n      h(\\n        'div',\\n        {\\n          style: {\\n            display: 'flex',\\n            alignItems: 'center',\\n            borderBottom: '1px solid #dee2e6',\\n            paddingRight: 8,\\n            paddingLeft: 8\\n          }\\n        },\\n        h(\\n          'h2',\\n          null,\\n          'Smitty Photo Booth Demo'\\n        ),\\n        h(\\n          'a',\\n          {\\n            href: 'https://github.com/tkh44/smitty/tree/master/demo/src',\\n            style: { fontSize: '1rem', color: '#329af0', marginLeft: 8 },\\n            target: '_blank'\\n          },\\n          'source'\\n        ),\\n        h(GithubRibbon, null)\\n      ),\\n      h(ImageList, null)\\n    )\\n  );\\n});\\n\\nvar Root = function Root(props) {\\n  return h(\\n    Provider,\\n    { store: store },\\n    h(App, null)\\n  );\\n};\\n\\nexport default Root;\"\n\n/***/ }),\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(\"ctQG\");\n\n\n/***/ }),\n\n/***/ \"22C0\":\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {var require;var require;/*!\n    localForage -- Offline Storage, Improved\n    Version 1.5.0\n    https://localforage.github.io/localForage\n    (c) 2013-2017 Mozilla, Apache License 2.0\n*/\n(function(f){if(true){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.localforage = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw (f.code=\"MODULE_NOT_FOUND\", f)}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\n(function (global){\n'use strict';\nvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\nvar scheduleDrain;\n\n{\n  if (Mutation) {\n    var called = 0;\n    var observer = new Mutation(nextTick);\n    var element = global.document.createTextNode('');\n    observer.observe(element, {\n      characterData: true\n    });\n    scheduleDrain = function () {\n      element.data = (called = ++called % 2);\n    };\n  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n    var channel = new global.MessageChannel();\n    channel.port1.onmessage = nextTick;\n    scheduleDrain = function () {\n      channel.port2.postMessage(0);\n    };\n  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n    scheduleDrain = function () {\n\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n      var scriptEl = global.document.createElement('script');\n      scriptEl.onreadystatechange = function () {\n        nextTick();\n\n        scriptEl.onreadystatechange = null;\n        scriptEl.parentNode.removeChild(scriptEl);\n        scriptEl = null;\n      };\n      global.document.documentElement.appendChild(scriptEl);\n    };\n  } else {\n    scheduleDrain = function () {\n      setTimeout(nextTick, 0);\n    };\n  }\n}\n\nvar draining;\nvar queue = [];\n//named nextTick for less confusing stack traces\nfunction nextTick() {\n  draining = true;\n  var i, oldQueue;\n  var len = queue.length;\n  while (len) {\n    oldQueue = queue;\n    queue = [];\n    i = -1;\n    while (++i < len) {\n      oldQueue[i]();\n    }\n    len = queue.length;\n  }\n  draining = false;\n}\n\nmodule.exports = immediate;\nfunction immediate(task) {\n  if (queue.push(task) === 1 && !draining) {\n    scheduleDrain();\n  }\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],2:[function(_dereq_,module,exports){\n'use strict';\nvar immediate = _dereq_(1);\n\n/* istanbul ignore next */\nfunction INTERNAL() {}\n\nvar handlers = {};\n\nvar REJECTED = ['REJECTED'];\nvar FULFILLED = ['FULFILLED'];\nvar PENDING = ['PENDING'];\n\nmodule.exports = exports = Promise;\n\nfunction Promise(resolver) {\n  if (typeof resolver !== 'function') {\n    throw new TypeError('resolver must be a function');\n  }\n  this.state = PENDING;\n  this.queue = [];\n  this.outcome = void 0;\n  if (resolver !== INTERNAL) {\n    safelyResolveThenable(this, resolver);\n  }\n}\n\nPromise.prototype[\"catch\"] = function (onRejected) {\n  return this.then(null, onRejected);\n};\nPromise.prototype.then = function (onFulfilled, onRejected) {\n  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||\n    typeof onRejected !== 'function' && this.state === REJECTED) {\n    return this;\n  }\n  var promise = new this.constructor(INTERNAL);\n  if (this.state !== PENDING) {\n    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n    unwrap(promise, resolver, this.outcome);\n  } else {\n    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n  }\n\n  return promise;\n};\nfunction QueueItem(promise, onFulfilled, onRejected) {\n  this.promise = promise;\n  if (typeof onFulfilled === 'function') {\n    this.onFulfilled = onFulfilled;\n    this.callFulfilled = this.otherCallFulfilled;\n  }\n  if (typeof onRejected === 'function') {\n    this.onRejected = onRejected;\n    this.callRejected = this.otherCallRejected;\n  }\n}\nQueueItem.prototype.callFulfilled = function (value) {\n  handlers.resolve(this.promise, value);\n};\nQueueItem.prototype.otherCallFulfilled = function (value) {\n  unwrap(this.promise, this.onFulfilled, value);\n};\nQueueItem.prototype.callRejected = function (value) {\n  handlers.reject(this.promise, value);\n};\nQueueItem.prototype.otherCallRejected = function (value) {\n  unwrap(this.promise, this.onRejected, value);\n};\n\nfunction unwrap(promise, func, value) {\n  immediate(function () {\n    var returnValue;\n    try {\n      returnValue = func(value);\n    } catch (e) {\n      return handlers.reject(promise, e);\n    }\n    if (returnValue === promise) {\n      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n    } else {\n      handlers.resolve(promise, returnValue);\n    }\n  });\n}\n\nhandlers.resolve = function (self, value) {\n  var result = tryCatch(getThen, value);\n  if (result.status === 'error') {\n    return handlers.reject(self, result.value);\n  }\n  var thenable = result.value;\n\n  if (thenable) {\n    safelyResolveThenable(self, thenable);\n  } else {\n    self.state = FULFILLED;\n    self.outcome = value;\n    var i = -1;\n    var len = self.queue.length;\n    while (++i < len) {\n      self.queue[i].callFulfilled(value);\n    }\n  }\n  return self;\n};\nhandlers.reject = function (self, error) {\n  self.state = REJECTED;\n  self.outcome = error;\n  var i = -1;\n  var len = self.queue.length;\n  while (++i < len) {\n    self.queue[i].callRejected(error);\n  }\n  return self;\n};\n\nfunction getThen(obj) {\n  // Make sure we only access the accessor once as required by the spec\n  var then = obj && obj.then;\n  if (obj && typeof obj === 'object' && typeof then === 'function') {\n    return function appyThen() {\n      then.apply(obj, arguments);\n    };\n  }\n}\n\nfunction safelyResolveThenable(self, thenable) {\n  // Either fulfill, reject or reject with error\n  var called = false;\n  function onError(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.reject(self, value);\n  }\n\n  function onSuccess(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.resolve(self, value);\n  }\n\n  function tryToUnwrap() {\n    thenable(onSuccess, onError);\n  }\n\n  var result = tryCatch(tryToUnwrap);\n  if (result.status === 'error') {\n    onError(result.value);\n  }\n}\n\nfunction tryCatch(func, value) {\n  var out = {};\n  try {\n    out.value = func(value);\n    out.status = 'success';\n  } catch (e) {\n    out.status = 'error';\n    out.value = e;\n  }\n  return out;\n}\n\nexports.resolve = resolve;\nfunction resolve(value) {\n  if (value instanceof this) {\n    return value;\n  }\n  return handlers.resolve(new this(INTERNAL), value);\n}\n\nexports.reject = reject;\nfunction reject(reason) {\n  var promise = new this(INTERNAL);\n  return handlers.reject(promise, reason);\n}\n\nexports.all = all;\nfunction all(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var values = new Array(len);\n  var resolved = 0;\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    allResolver(iterable[i], i);\n  }\n  return promise;\n  function allResolver(value, i) {\n    self.resolve(value).then(resolveFromAll, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n    function resolveFromAll(outValue) {\n      values[i] = outValue;\n      if (++resolved === len && !called) {\n        called = true;\n        handlers.resolve(promise, values);\n      }\n    }\n  }\n}\n\nexports.race = race;\nfunction race(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    resolver(iterable[i]);\n  }\n  return promise;\n  function resolver(value) {\n    self.resolve(value).then(function (response) {\n      if (!called) {\n        called = true;\n        handlers.resolve(promise, response);\n      }\n    }, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n  }\n}\n\n},{\"1\":1}],3:[function(_dereq_,module,exports){\n(function (global){\n'use strict';\nif (typeof global.Promise !== 'function') {\n  global.Promise = _dereq_(2);\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"2\":2}],4:[function(_dereq_,module,exports){\n'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction getIDB() {\n    /* global indexedDB,webkitIndexedDB,mozIndexedDB,OIndexedDB,msIndexedDB */\n    try {\n        if (typeof indexedDB !== 'undefined') {\n            return indexedDB;\n        }\n        if (typeof webkitIndexedDB !== 'undefined') {\n            return webkitIndexedDB;\n        }\n        if (typeof mozIndexedDB !== 'undefined') {\n            return mozIndexedDB;\n        }\n        if (typeof OIndexedDB !== 'undefined') {\n            return OIndexedDB;\n        }\n        if (typeof msIndexedDB !== 'undefined') {\n            return msIndexedDB;\n        }\n    } catch (e) {}\n}\n\nvar idb = getIDB();\n\nfunction isIndexedDBValid() {\n    try {\n        // Initialize IndexedDB; fall back to vendor-prefixed versions\n        // if needed.\n        if (!idb) {\n            return false;\n        }\n        // We mimic PouchDB here;\n        //\n        // We test for openDatabase because IE Mobile identifies itself\n        // as Safari. Oh the lulz...\n        var isSafari = typeof openDatabase !== 'undefined' && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);\n\n        var hasFetch = typeof fetch === 'function' && fetch.toString().indexOf('[native code') !== -1;\n\n        // Safari <10.1 does not meet our requirements for IDB support (#5572)\n        // since Safari 10.1 shipped with fetch, we can use that to detect it\n        return (!isSafari || hasFetch) && typeof indexedDB !== 'undefined' &&\n        // some outdated implementations of IDB that appear on Samsung\n        // and HTC Android devices <4.4 are missing IDBKeyRange\n        typeof IDBKeyRange !== 'undefined';\n    } catch (e) {\n        return false;\n    }\n}\n\nfunction isWebSQLValid() {\n    return typeof openDatabase === 'function';\n}\n\nfunction isLocalStorageValid() {\n    try {\n        return typeof localStorage !== 'undefined' && 'setItem' in localStorage && localStorage.setItem;\n    } catch (e) {\n        return false;\n    }\n}\n\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor. (i.e.\n// old QtWebKit versions, at least).\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor. (i.e.\n// old QtWebKit versions, at least).\nfunction createBlob(parts, properties) {\n    /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n    parts = parts || [];\n    properties = properties || {};\n    try {\n        return new Blob(parts, properties);\n    } catch (e) {\n        if (e.name !== 'TypeError') {\n            throw e;\n        }\n        var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : WebKitBlobBuilder;\n        var builder = new Builder();\n        for (var i = 0; i < parts.length; i += 1) {\n            builder.append(parts[i]);\n        }\n        return builder.getBlob(properties.type);\n    }\n}\n\n// This is CommonJS because lie is an external dependency, so Rollup\n// can just ignore it.\nif (typeof Promise === 'undefined') {\n    // In the \"nopromises\" build this will just throw if you don't have\n    // a global promise object, but it would throw anyway later.\n    _dereq_(3);\n}\nvar Promise$1 = Promise;\n\nfunction executeCallback(promise, callback) {\n    if (callback) {\n        promise.then(function (result) {\n            callback(null, result);\n        }, function (error) {\n            callback(error);\n        });\n    }\n}\n\nfunction executeTwoCallbacks(promise, callback, errorCallback) {\n    if (typeof callback === 'function') {\n        promise.then(callback);\n    }\n\n    if (typeof errorCallback === 'function') {\n        promise[\"catch\"](errorCallback);\n    }\n}\n\n// Some code originally from async_storage.js in\n// [Gaia](https://github.com/mozilla-b2g/gaia).\n\nvar DETECT_BLOB_SUPPORT_STORE = 'local-forage-detect-blob-support';\nvar supportsBlobs;\nvar dbContexts;\nvar toString = Object.prototype.toString;\n\n// Transform a binary string to an array buffer, because otherwise\n// weird stuff happens when you try to work with the binary string directly.\n// It is known.\n// From http://stackoverflow.com/questions/14967647/ (continues on next line)\n// encode-decode-image-with-base64-breaks-image (2013-04-21)\nfunction _binStringToArrayBuffer(bin) {\n    var length = bin.length;\n    var buf = new ArrayBuffer(length);\n    var arr = new Uint8Array(buf);\n    for (var i = 0; i < length; i++) {\n        arr[i] = bin.charCodeAt(i);\n    }\n    return buf;\n}\n\n//\n// Blobs are not supported in all versions of IndexedDB, notably\n// Chrome <37 and Android <5. In those versions, storing a blob will throw.\n//\n// Various other blob bugs exist in Chrome v37-42 (inclusive).\n// Detecting them is expensive and confusing to users, and Chrome 37-42\n// is at very low usage worldwide, so we do a hacky userAgent check instead.\n//\n// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\n// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n//\n// Code borrowed from PouchDB. See:\n// https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-adapter-idb/src/blobSupport.js\n//\nfunction _checkBlobSupportWithoutCaching(idb) {\n    return new Promise$1(function (resolve) {\n        var txn = idb.transaction(DETECT_BLOB_SUPPORT_STORE, 'readwrite');\n        var blob = createBlob(['']);\n        txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');\n\n        txn.onabort = function (e) {\n            // If the transaction aborts now its due to not being able to\n            // write to the database, likely due to the disk being full\n            e.preventDefault();\n            e.stopPropagation();\n            resolve(false);\n        };\n\n        txn.oncomplete = function () {\n            var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n            var matchedEdge = navigator.userAgent.match(/Edge\\//);\n            // MS Edge pretends to be Chrome 42:\n            // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\n            resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);\n        };\n    })[\"catch\"](function () {\n        return false; // error, so assume unsupported\n    });\n}\n\nfunction _checkBlobSupport(idb) {\n    if (typeof supportsBlobs === 'boolean') {\n        return Promise$1.resolve(supportsBlobs);\n    }\n    return _checkBlobSupportWithoutCaching(idb).then(function (value) {\n        supportsBlobs = value;\n        return supportsBlobs;\n    });\n}\n\nfunction _deferReadiness(dbInfo) {\n    var dbContext = dbContexts[dbInfo.name];\n\n    // Create a deferred object representing the current database operation.\n    var deferredOperation = {};\n\n    deferredOperation.promise = new Promise$1(function (resolve) {\n        deferredOperation.resolve = resolve;\n    });\n\n    // Enqueue the deferred operation.\n    dbContext.deferredOperations.push(deferredOperation);\n\n    // Chain its promise to the database readiness.\n    if (!dbContext.dbReady) {\n        dbContext.dbReady = deferredOperation.promise;\n    } else {\n        dbContext.dbReady = dbContext.dbReady.then(function () {\n            return deferredOperation.promise;\n        });\n    }\n}\n\nfunction _advanceReadiness(dbInfo) {\n    var dbContext = dbContexts[dbInfo.name];\n\n    // Dequeue a deferred operation.\n    var deferredOperation = dbContext.deferredOperations.pop();\n\n    // Resolve its promise (which is part of the database readiness\n    // chain of promises).\n    if (deferredOperation) {\n        deferredOperation.resolve();\n    }\n}\n\nfunction _getConnection(dbInfo, upgradeNeeded) {\n    return new Promise$1(function (resolve, reject) {\n\n        if (dbInfo.db) {\n            if (upgradeNeeded) {\n                _deferReadiness(dbInfo);\n                dbInfo.db.close();\n            } else {\n                return resolve(dbInfo.db);\n            }\n        }\n\n        var dbArgs = [dbInfo.name];\n\n        if (upgradeNeeded) {\n            dbArgs.push(dbInfo.version);\n        }\n\n        var openreq = idb.open.apply(idb, dbArgs);\n\n        if (upgradeNeeded) {\n            openreq.onupgradeneeded = function (e) {\n                var db = openreq.result;\n                try {\n                    db.createObjectStore(dbInfo.storeName);\n                    if (e.oldVersion <= 1) {\n                        // Added when support for blob shims was added\n                        db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n                    }\n                } catch (ex) {\n                    if (ex.name === 'ConstraintError') {\n                        console.warn('The database \"' + dbInfo.name + '\"' + ' has been upgraded from version ' + e.oldVersion + ' to version ' + e.newVersion + ', but the storage \"' + dbInfo.storeName + '\" already exists.');\n                    } else {\n                        throw ex;\n                    }\n                }\n            };\n        }\n\n        openreq.onerror = function (e) {\n            e.preventDefault();\n            reject(openreq.error);\n        };\n\n        openreq.onsuccess = function () {\n            resolve(openreq.result);\n            _advanceReadiness(dbInfo);\n        };\n    });\n}\n\nfunction _getOriginalConnection(dbInfo) {\n    return _getConnection(dbInfo, false);\n}\n\nfunction _getUpgradedConnection(dbInfo) {\n    return _getConnection(dbInfo, true);\n}\n\nfunction _isUpgradeNeeded(dbInfo, defaultVersion) {\n    if (!dbInfo.db) {\n        return true;\n    }\n\n    var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);\n    var isDowngrade = dbInfo.version < dbInfo.db.version;\n    var isUpgrade = dbInfo.version > dbInfo.db.version;\n\n    if (isDowngrade) {\n        // If the version is not the default one\n        // then warn for impossible downgrade.\n        if (dbInfo.version !== defaultVersion) {\n            console.warn('The database \"' + dbInfo.name + '\"' + ' can\\'t be downgraded from version ' + dbInfo.db.version + ' to version ' + dbInfo.version + '.');\n        }\n        // Align the versions to prevent errors.\n        dbInfo.version = dbInfo.db.version;\n    }\n\n    if (isUpgrade || isNewStore) {\n        // If the store is new then increment the version (if needed).\n        // This will trigger an \"upgradeneeded\" event which is required\n        // for creating a store.\n        if (isNewStore) {\n            var incVersion = dbInfo.db.version + 1;\n            if (incVersion > dbInfo.version) {\n                dbInfo.version = incVersion;\n            }\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n// encode a blob for indexeddb engines that don't support blobs\nfunction _encodeBlob(blob) {\n    return new Promise$1(function (resolve, reject) {\n        var reader = new FileReader();\n        reader.onerror = reject;\n        reader.onloadend = function (e) {\n            var base64 = btoa(e.target.result || '');\n            resolve({\n                __local_forage_encoded_blob: true,\n                data: base64,\n                type: blob.type\n            });\n        };\n        reader.readAsBinaryString(blob);\n    });\n}\n\n// decode an encoded blob\nfunction _decodeBlob(encodedBlob) {\n    var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));\n    return createBlob([arrayBuff], { type: encodedBlob.type });\n}\n\n// is this one of our fancy encoded blobs?\nfunction _isEncodedBlob(value) {\n    return value && value.__local_forage_encoded_blob;\n}\n\n// Specialize the default `ready()` function by making it dependent\n// on the current database operations. Thus, the driver will be actually\n// ready when it's been initialized (default) *and* there are no pending\n// operations on the database (initiated by some other instances).\nfunction _fullyReady(callback) {\n    var self = this;\n\n    var promise = self._initReady().then(function () {\n        var dbContext = dbContexts[self._dbInfo.name];\n\n        if (dbContext && dbContext.dbReady) {\n            return dbContext.dbReady;\n        }\n    });\n\n    executeTwoCallbacks(promise, callback, callback);\n    return promise;\n}\n\n// Open the IndexedDB database (automatically creates one if one didn't\n// previously exist), using any options set in the config.\nfunction _initStorage(options) {\n    var self = this;\n    var dbInfo = {\n        db: null\n    };\n\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = options[i];\n        }\n    }\n\n    // Initialize a singleton container for all running localForages.\n    if (!dbContexts) {\n        dbContexts = {};\n    }\n\n    // Get the current context of the database;\n    var dbContext = dbContexts[dbInfo.name];\n\n    // ...or create a new context.\n    if (!dbContext) {\n        dbContext = {\n            // Running localForages sharing a database.\n            forages: [],\n            // Shared database.\n            db: null,\n            // Database readiness (promise).\n            dbReady: null,\n            // Deferred operations on the database.\n            deferredOperations: []\n        };\n        // Register the new context in the global container.\n        dbContexts[dbInfo.name] = dbContext;\n    }\n\n    // Register itself as a running localForage in the current context.\n    dbContext.forages.push(self);\n\n    // Replace the default `ready()` function with the specialized one.\n    if (!self._initReady) {\n        self._initReady = self.ready;\n        self.ready = _fullyReady;\n    }\n\n    // Create an array of initialization states of the related localForages.\n    var initPromises = [];\n\n    function ignoreErrors() {\n        // Don't handle errors here,\n        // just makes sure related localForages aren't pending.\n        return Promise$1.resolve();\n    }\n\n    for (var j = 0; j < dbContext.forages.length; j++) {\n        var forage = dbContext.forages[j];\n        if (forage !== self) {\n            // Don't wait for itself...\n            initPromises.push(forage._initReady()[\"catch\"](ignoreErrors));\n        }\n    }\n\n    // Take a snapshot of the related localForages.\n    var forages = dbContext.forages.slice(0);\n\n    // Initialize the connection process only when\n    // all the related localForages aren't pending.\n    return Promise$1.all(initPromises).then(function () {\n        dbInfo.db = dbContext.db;\n        // Get the connection or open a new one without upgrade.\n        return _getOriginalConnection(dbInfo);\n    }).then(function (db) {\n        dbInfo.db = db;\n        if (_isUpgradeNeeded(dbInfo, self._defaultConfig.version)) {\n            // Reopen the database for upgrading.\n            return _getUpgradedConnection(dbInfo);\n        }\n        return db;\n    }).then(function (db) {\n        dbInfo.db = dbContext.db = db;\n        self._dbInfo = dbInfo;\n        // Share the final connection amongst related localForages.\n        for (var k = 0; k < forages.length; k++) {\n            var forage = forages[k];\n            if (forage !== self) {\n                // Self is already up-to-date.\n                forage._dbInfo.db = dbInfo.db;\n                forage._dbInfo.version = dbInfo.version;\n            }\n        }\n    });\n}\n\nfunction getItem(key, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);\n            var req = store.get(key);\n\n            req.onsuccess = function () {\n                var value = req.result;\n                if (value === undefined) {\n                    value = null;\n                }\n                if (_isEncodedBlob(value)) {\n                    value = _decodeBlob(value);\n                }\n                resolve(value);\n            };\n\n            req.onerror = function () {\n                reject(req.error);\n            };\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Iterate over all items stored in database.\nfunction iterate(iterator, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);\n\n            var req = store.openCursor();\n            var iterationNumber = 1;\n\n            req.onsuccess = function () {\n                var cursor = req.result;\n\n                if (cursor) {\n                    var value = cursor.value;\n                    if (_isEncodedBlob(value)) {\n                        value = _decodeBlob(value);\n                    }\n                    var result = iterator(value, cursor.key, iterationNumber++);\n\n                    if (result !== void 0) {\n                        resolve(result);\n                    } else {\n                        cursor[\"continue\"]();\n                    }\n                } else {\n                    resolve();\n                }\n            };\n\n            req.onerror = function () {\n                reject(req.error);\n            };\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n\n    return promise;\n}\n\nfunction setItem(key, value, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = new Promise$1(function (resolve, reject) {\n        var dbInfo;\n        self.ready().then(function () {\n            dbInfo = self._dbInfo;\n            if (toString.call(value) === '[object Blob]') {\n                return _checkBlobSupport(dbInfo.db).then(function (blobSupport) {\n                    if (blobSupport) {\n                        return value;\n                    }\n                    return _encodeBlob(value);\n                });\n            }\n            return value;\n        }).then(function (value) {\n            var transaction = dbInfo.db.transaction(dbInfo.storeName, 'readwrite');\n            var store = transaction.objectStore(dbInfo.storeName);\n            var req = store.put(value, key);\n\n            // The reason we don't _save_ null is because IE 10 does\n            // not support saving the `null` type in IndexedDB. How\n            // ironic, given the bug below!\n            // See: https://github.com/mozilla/localForage/issues/161\n            if (value === null) {\n                value = undefined;\n            }\n\n            transaction.oncomplete = function () {\n                // Cast to undefined so the value passed to\n                // callback/promise is the same as what one would get out\n                // of `getItem()` later. This leads to some weirdness\n                // (setItem('foo', undefined) will return `null`), but\n                // it's not my fault localStorage is our baseline and that\n                // it's weird.\n                if (value === undefined) {\n                    value = null;\n                }\n\n                resolve(value);\n            };\n            transaction.onabort = transaction.onerror = function () {\n                var err = req.error ? req.error : req.transaction.error;\n                reject(err);\n            };\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction removeItem(key, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var transaction = dbInfo.db.transaction(dbInfo.storeName, 'readwrite');\n            var store = transaction.objectStore(dbInfo.storeName);\n\n            // We use a Grunt task to make this safe for IE and some\n            // versions of Android (including those used by Cordova).\n            // Normally IE won't like `.delete()` and will insist on\n            // using `['delete']()`, but we have a build step that\n            // fixes this for us now.\n            var req = store[\"delete\"](key);\n            transaction.oncomplete = function () {\n                resolve();\n            };\n\n            transaction.onerror = function () {\n                reject(req.error);\n            };\n\n            // The request will be also be aborted if we've exceeded our storage\n            // space.\n            transaction.onabort = function () {\n                var err = req.error ? req.error : req.transaction.error;\n                reject(err);\n            };\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction clear(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var transaction = dbInfo.db.transaction(dbInfo.storeName, 'readwrite');\n            var store = transaction.objectStore(dbInfo.storeName);\n            var req = store.clear();\n\n            transaction.oncomplete = function () {\n                resolve();\n            };\n\n            transaction.onabort = transaction.onerror = function () {\n                var err = req.error ? req.error : req.transaction.error;\n                reject(err);\n            };\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction length(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);\n            var req = store.count();\n\n            req.onsuccess = function () {\n                resolve(req.result);\n            };\n\n            req.onerror = function () {\n                reject(req.error);\n            };\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction key(n, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        if (n < 0) {\n            resolve(null);\n\n            return;\n        }\n\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);\n\n            var advanced = false;\n            var req = store.openCursor();\n            req.onsuccess = function () {\n                var cursor = req.result;\n                if (!cursor) {\n                    // this means there weren't enough keys\n                    resolve(null);\n\n                    return;\n                }\n\n                if (n === 0) {\n                    // We have the first key, return it if that's what they\n                    // wanted.\n                    resolve(cursor.key);\n                } else {\n                    if (!advanced) {\n                        // Otherwise, ask the cursor to skip ahead n\n                        // records.\n                        advanced = true;\n                        cursor.advance(n);\n                    } else {\n                        // When we get here, we've got the nth key.\n                        resolve(cursor.key);\n                    }\n                }\n            };\n\n            req.onerror = function () {\n                reject(req.error);\n            };\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);\n\n            var req = store.openCursor();\n            var keys = [];\n\n            req.onsuccess = function () {\n                var cursor = req.result;\n\n                if (!cursor) {\n                    resolve(keys);\n                    return;\n                }\n\n                keys.push(cursor.key);\n                cursor[\"continue\"]();\n            };\n\n            req.onerror = function () {\n                reject(req.error);\n            };\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar asyncStorage = {\n    _driver: 'asyncStorage',\n    _initStorage: _initStorage,\n    iterate: iterate,\n    getItem: getItem,\n    setItem: setItem,\n    removeItem: removeItem,\n    clear: clear,\n    length: length,\n    key: key,\n    keys: keys\n};\n\n// Sadly, the best way to save binary data in WebSQL/localStorage is serializing\n// it to Base64, so this is how we store it to prevent very strange errors with less\n// verbose ways of binary <-> string data storage.\nvar BASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\nvar BLOB_TYPE_PREFIX = '~~local_forage_type~';\nvar BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;\n\nvar SERIALIZED_MARKER = '__lfsc__:';\nvar SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;\n\n// OMG the serializations!\nvar TYPE_ARRAYBUFFER = 'arbf';\nvar TYPE_BLOB = 'blob';\nvar TYPE_INT8ARRAY = 'si08';\nvar TYPE_UINT8ARRAY = 'ui08';\nvar TYPE_UINT8CLAMPEDARRAY = 'uic8';\nvar TYPE_INT16ARRAY = 'si16';\nvar TYPE_INT32ARRAY = 'si32';\nvar TYPE_UINT16ARRAY = 'ur16';\nvar TYPE_UINT32ARRAY = 'ui32';\nvar TYPE_FLOAT32ARRAY = 'fl32';\nvar TYPE_FLOAT64ARRAY = 'fl64';\nvar TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;\n\nvar toString$1 = Object.prototype.toString;\n\nfunction stringToBuffer(serializedString) {\n    // Fill the string into a ArrayBuffer.\n    var bufferLength = serializedString.length * 0.75;\n    var len = serializedString.length;\n    var i;\n    var p = 0;\n    var encoded1, encoded2, encoded3, encoded4;\n\n    if (serializedString[serializedString.length - 1] === '=') {\n        bufferLength--;\n        if (serializedString[serializedString.length - 2] === '=') {\n            bufferLength--;\n        }\n    }\n\n    var buffer = new ArrayBuffer(bufferLength);\n    var bytes = new Uint8Array(buffer);\n\n    for (i = 0; i < len; i += 4) {\n        encoded1 = BASE_CHARS.indexOf(serializedString[i]);\n        encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);\n        encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);\n        encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);\n\n        /*jslint bitwise: true */\n        bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n    }\n    return buffer;\n}\n\n// Converts a buffer to a string to store, serialized, in the backend\n// storage library.\nfunction bufferToString(buffer) {\n    // base64-arraybuffer\n    var bytes = new Uint8Array(buffer);\n    var base64String = '';\n    var i;\n\n    for (i = 0; i < bytes.length; i += 3) {\n        /*jslint bitwise: true */\n        base64String += BASE_CHARS[bytes[i] >> 2];\n        base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];\n        base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];\n        base64String += BASE_CHARS[bytes[i + 2] & 63];\n    }\n\n    if (bytes.length % 3 === 2) {\n        base64String = base64String.substring(0, base64String.length - 1) + '=';\n    } else if (bytes.length % 3 === 1) {\n        base64String = base64String.substring(0, base64String.length - 2) + '==';\n    }\n\n    return base64String;\n}\n\n// Serialize a value, afterwards executing a callback (which usually\n// instructs the `setItem()` callback/promise to be executed). This is how\n// we store binary data with localStorage.\nfunction serialize(value, callback) {\n    var valueType = '';\n    if (value) {\n        valueType = toString$1.call(value);\n    }\n\n    // Cannot use `value instanceof ArrayBuffer` or such here, as these\n    // checks fail when running the tests using casper.js...\n    //\n    // TODO: See why those tests fail and use a better solution.\n    if (value && (valueType === '[object ArrayBuffer]' || value.buffer && toString$1.call(value.buffer) === '[object ArrayBuffer]')) {\n        // Convert binary arrays to a string and prefix the string with\n        // a special marker.\n        var buffer;\n        var marker = SERIALIZED_MARKER;\n\n        if (value instanceof ArrayBuffer) {\n            buffer = value;\n            marker += TYPE_ARRAYBUFFER;\n        } else {\n            buffer = value.buffer;\n\n            if (valueType === '[object Int8Array]') {\n                marker += TYPE_INT8ARRAY;\n            } else if (valueType === '[object Uint8Array]') {\n                marker += TYPE_UINT8ARRAY;\n            } else if (valueType === '[object Uint8ClampedArray]') {\n                marker += TYPE_UINT8CLAMPEDARRAY;\n            } else if (valueType === '[object Int16Array]') {\n                marker += TYPE_INT16ARRAY;\n            } else if (valueType === '[object Uint16Array]') {\n                marker += TYPE_UINT16ARRAY;\n            } else if (valueType === '[object Int32Array]') {\n                marker += TYPE_INT32ARRAY;\n            } else if (valueType === '[object Uint32Array]') {\n                marker += TYPE_UINT32ARRAY;\n            } else if (valueType === '[object Float32Array]') {\n                marker += TYPE_FLOAT32ARRAY;\n            } else if (valueType === '[object Float64Array]') {\n                marker += TYPE_FLOAT64ARRAY;\n            } else {\n                callback(new Error('Failed to get type for BinaryArray'));\n            }\n        }\n\n        callback(marker + bufferToString(buffer));\n    } else if (valueType === '[object Blob]') {\n        // Conver the blob to a binaryArray and then to a string.\n        var fileReader = new FileReader();\n\n        fileReader.onload = function () {\n            // Backwards-compatible prefix for the blob type.\n            var str = BLOB_TYPE_PREFIX + value.type + '~' + bufferToString(this.result);\n\n            callback(SERIALIZED_MARKER + TYPE_BLOB + str);\n        };\n\n        fileReader.readAsArrayBuffer(value);\n    } else {\n        try {\n            callback(JSON.stringify(value));\n        } catch (e) {\n            console.error(\"Couldn't convert value into a JSON string: \", value);\n\n            callback(null, e);\n        }\n    }\n}\n\n// Deserialize data we've inserted into a value column/field. We place\n// special markers into our strings to mark them as encoded; this isn't\n// as nice as a meta field, but it's the only sane thing we can do whilst\n// keeping localStorage support intact.\n//\n// Oftentimes this will just deserialize JSON content, but if we have a\n// special marker (SERIALIZED_MARKER, defined above), we will extract\n// some kind of arraybuffer/binary data/typed array out of the string.\nfunction deserialize(value) {\n    // If we haven't marked this string as being specially serialized (i.e.\n    // something other than serialized JSON), we can just return it and be\n    // done with it.\n    if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {\n        return JSON.parse(value);\n    }\n\n    // The following code deals with deserializing some kind of Blob or\n    // TypedArray. First we separate out the type of data we're dealing\n    // with from the data itself.\n    var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);\n    var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);\n\n    var blobType;\n    // Backwards-compatible blob type serialization strategy.\n    // DBs created with older versions of localForage will simply not have the blob type.\n    if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {\n        var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);\n        blobType = matcher[1];\n        serializedString = serializedString.substring(matcher[0].length);\n    }\n    var buffer = stringToBuffer(serializedString);\n\n    // Return the right type based on the code/type set during\n    // serialization.\n    switch (type) {\n        case TYPE_ARRAYBUFFER:\n            return buffer;\n        case TYPE_BLOB:\n            return createBlob([buffer], { type: blobType });\n        case TYPE_INT8ARRAY:\n            return new Int8Array(buffer);\n        case TYPE_UINT8ARRAY:\n            return new Uint8Array(buffer);\n        case TYPE_UINT8CLAMPEDARRAY:\n            return new Uint8ClampedArray(buffer);\n        case TYPE_INT16ARRAY:\n            return new Int16Array(buffer);\n        case TYPE_UINT16ARRAY:\n            return new Uint16Array(buffer);\n        case TYPE_INT32ARRAY:\n            return new Int32Array(buffer);\n        case TYPE_UINT32ARRAY:\n            return new Uint32Array(buffer);\n        case TYPE_FLOAT32ARRAY:\n            return new Float32Array(buffer);\n        case TYPE_FLOAT64ARRAY:\n            return new Float64Array(buffer);\n        default:\n            throw new Error('Unkown type: ' + type);\n    }\n}\n\nvar localforageSerializer = {\n    serialize: serialize,\n    deserialize: deserialize,\n    stringToBuffer: stringToBuffer,\n    bufferToString: bufferToString\n};\n\n/*\n * Includes code from:\n *\n * base64-arraybuffer\n * https://github.com/niklasvh/base64-arraybuffer\n *\n * Copyright (c) 2012 Niklas von Hertzen\n * Licensed under the MIT license.\n */\n// Open the WebSQL database (automatically creates one if one didn't\n// previously exist), using any options set in the config.\nfunction _initStorage$1(options) {\n    var self = this;\n    var dbInfo = {\n        db: null\n    };\n\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = typeof options[i] !== 'string' ? options[i].toString() : options[i];\n        }\n    }\n\n    var dbInfoPromise = new Promise$1(function (resolve, reject) {\n        // Open the database; the openDatabase API will automatically\n        // create it for us if it doesn't exist.\n        try {\n            dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);\n        } catch (e) {\n            return reject(e);\n        }\n\n        // Create our key/value table if it doesn't exist.\n        dbInfo.db.transaction(function (t) {\n            t.executeSql('CREATE TABLE IF NOT EXISTS ' + dbInfo.storeName + ' (id INTEGER PRIMARY KEY, key unique, value)', [], function () {\n                self._dbInfo = dbInfo;\n                resolve();\n            }, function (t, error) {\n                reject(error);\n            });\n        });\n    });\n\n    dbInfo.serializer = localforageSerializer;\n    return dbInfoPromise;\n}\n\nfunction getItem$1(key, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('SELECT * FROM ' + dbInfo.storeName + ' WHERE key = ? LIMIT 1', [key], function (t, results) {\n                    var result = results.rows.length ? results.rows.item(0).value : null;\n\n                    // Check to see if this is serialized content we need to\n                    // unpack.\n                    if (result) {\n                        result = dbInfo.serializer.deserialize(result);\n                    }\n\n                    resolve(result);\n                }, function (t, error) {\n\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction iterate$1(iterator, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('SELECT * FROM ' + dbInfo.storeName, [], function (t, results) {\n                    var rows = results.rows;\n                    var length = rows.length;\n\n                    for (var i = 0; i < length; i++) {\n                        var item = rows.item(i);\n                        var result = item.value;\n\n                        // Check to see if this is serialized content\n                        // we need to unpack.\n                        if (result) {\n                            result = dbInfo.serializer.deserialize(result);\n                        }\n\n                        result = iterator(result, item.key, i + 1);\n\n                        // void(0) prevents problems with redefinition\n                        // of `undefined`.\n                        if (result !== void 0) {\n                            resolve(result);\n                            return;\n                        }\n                    }\n\n                    resolve();\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction _setItem(key, value, callback, retriesLeft) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            // The localStorage API doesn't return undefined values in an\n            // \"expected\" way, so undefined is always cast to null in all\n            // drivers. See: https://github.com/mozilla/localForage/pull/42\n            if (value === undefined) {\n                value = null;\n            }\n\n            // Save the original value to pass to the callback.\n            var originalValue = value;\n\n            var dbInfo = self._dbInfo;\n            dbInfo.serializer.serialize(value, function (value, error) {\n                if (error) {\n                    reject(error);\n                } else {\n                    dbInfo.db.transaction(function (t) {\n                        t.executeSql('INSERT OR REPLACE INTO ' + dbInfo.storeName + ' (key, value) VALUES (?, ?)', [key, value], function () {\n                            resolve(originalValue);\n                        }, function (t, error) {\n                            reject(error);\n                        });\n                    }, function (sqlError) {\n                        // The transaction failed; check\n                        // to see if it's a quota error.\n                        if (sqlError.code === sqlError.QUOTA_ERR) {\n                            // We reject the callback outright for now, but\n                            // it's worth trying to re-run the transaction.\n                            // Even if the user accepts the prompt to use\n                            // more storage on Safari, this error will\n                            // be called.\n                            //\n                            // Try to re-run the transaction.\n                            if (retriesLeft > 0) {\n                                resolve(_setItem.apply(self, [key, originalValue, callback, retriesLeft - 1]));\n                                return;\n                            }\n                            reject(sqlError);\n                        }\n                    });\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction setItem$1(key, value, callback) {\n    return _setItem.apply(this, [key, value, callback, 1]);\n}\n\nfunction removeItem$1(key, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('DELETE FROM ' + dbInfo.storeName + ' WHERE key = ?', [key], function () {\n                    resolve();\n                }, function (t, error) {\n\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Deletes every item in the table.\n// TODO: Find out if this resets the AUTO_INCREMENT number.\nfunction clear$1(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('DELETE FROM ' + dbInfo.storeName, [], function () {\n                    resolve();\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Does a simple `COUNT(key)` to get the number of items stored in\n// localForage.\nfunction length$1(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                // Ahhh, SQL makes this one soooooo easy.\n                t.executeSql('SELECT COUNT(key) as c FROM ' + dbInfo.storeName, [], function (t, results) {\n                    var result = results.rows.item(0).c;\n\n                    resolve(result);\n                }, function (t, error) {\n\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Return the key located at key index X; essentially gets the key from a\n// `WHERE id = ?`. This is the most efficient way I can think to implement\n// this rarely-used (in my experience) part of the API, but it can seem\n// inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so\n// the ID of each key will change every time it's updated. Perhaps a stored\n// procedure for the `setItem()` SQL would solve this problem?\n// TODO: Don't change ID on `setItem()`.\nfunction key$1(n, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('SELECT key FROM ' + dbInfo.storeName + ' WHERE id = ? LIMIT 1', [n + 1], function (t, results) {\n                    var result = results.rows.length ? results.rows.item(0).key : null;\n                    resolve(result);\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys$1(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('SELECT key FROM ' + dbInfo.storeName, [], function (t, results) {\n                    var keys = [];\n\n                    for (var i = 0; i < results.rows.length; i++) {\n                        keys.push(results.rows.item(i).key);\n                    }\n\n                    resolve(keys);\n                }, function (t, error) {\n\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar webSQLStorage = {\n    _driver: 'webSQLStorage',\n    _initStorage: _initStorage$1,\n    iterate: iterate$1,\n    getItem: getItem$1,\n    setItem: setItem$1,\n    removeItem: removeItem$1,\n    clear: clear$1,\n    length: length$1,\n    key: key$1,\n    keys: keys$1\n};\n\n// Config the localStorage backend, using options set in the config.\nfunction _initStorage$2(options) {\n    var self = this;\n    var dbInfo = {};\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = options[i];\n        }\n    }\n\n    dbInfo.keyPrefix = dbInfo.name + '/';\n\n    if (dbInfo.storeName !== self._defaultConfig.storeName) {\n        dbInfo.keyPrefix += dbInfo.storeName + '/';\n    }\n\n    self._dbInfo = dbInfo;\n    dbInfo.serializer = localforageSerializer;\n\n    return Promise$1.resolve();\n}\n\n// Remove all keys from the datastore, effectively destroying all data in\n// the app's key/value store!\nfunction clear$2(callback) {\n    var self = this;\n    var promise = self.ready().then(function () {\n        var keyPrefix = self._dbInfo.keyPrefix;\n\n        for (var i = localStorage.length - 1; i >= 0; i--) {\n            var key = localStorage.key(i);\n\n            if (key.indexOf(keyPrefix) === 0) {\n                localStorage.removeItem(key);\n            }\n        }\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Retrieve an item from the store. Unlike the original async_storage\n// library in Gaia, we don't modify return values at all. If a key's value\n// is `undefined`, we pass that value to the callback function.\nfunction getItem$2(key, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var result = localStorage.getItem(dbInfo.keyPrefix + key);\n\n        // If a result was found, parse it from the serialized\n        // string into a JS object. If result isn't truthy, the key\n        // is likely undefined and we'll pass it straight to the\n        // callback.\n        if (result) {\n            result = dbInfo.serializer.deserialize(result);\n        }\n\n        return result;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Iterate over all items in the store.\nfunction iterate$2(iterator, callback) {\n    var self = this;\n\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var keyPrefix = dbInfo.keyPrefix;\n        var keyPrefixLength = keyPrefix.length;\n        var length = localStorage.length;\n\n        // We use a dedicated iterator instead of the `i` variable below\n        // so other keys we fetch in localStorage aren't counted in\n        // the `iterationNumber` argument passed to the `iterate()`\n        // callback.\n        //\n        // See: github.com/mozilla/localForage/pull/435#discussion_r38061530\n        var iterationNumber = 1;\n\n        for (var i = 0; i < length; i++) {\n            var key = localStorage.key(i);\n            if (key.indexOf(keyPrefix) !== 0) {\n                continue;\n            }\n            var value = localStorage.getItem(key);\n\n            // If a result was found, parse it from the serialized\n            // string into a JS object. If result isn't truthy, the\n            // key is likely undefined and we'll pass it straight\n            // to the iterator.\n            if (value) {\n                value = dbInfo.serializer.deserialize(value);\n            }\n\n            value = iterator(value, key.substring(keyPrefixLength), iterationNumber++);\n\n            if (value !== void 0) {\n                return value;\n            }\n        }\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Same as localStorage's key() method, except takes a callback.\nfunction key$2(n, callback) {\n    var self = this;\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var result;\n        try {\n            result = localStorage.key(n);\n        } catch (error) {\n            result = null;\n        }\n\n        // Remove the prefix from the key, if a key is found.\n        if (result) {\n            result = result.substring(dbInfo.keyPrefix.length);\n        }\n\n        return result;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys$2(callback) {\n    var self = this;\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var length = localStorage.length;\n        var keys = [];\n\n        for (var i = 0; i < length; i++) {\n            if (localStorage.key(i).indexOf(dbInfo.keyPrefix) === 0) {\n                keys.push(localStorage.key(i).substring(dbInfo.keyPrefix.length));\n            }\n        }\n\n        return keys;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Supply the number of keys in the datastore to the callback function.\nfunction length$2(callback) {\n    var self = this;\n    var promise = self.keys().then(function (keys) {\n        return keys.length;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Remove an item from the store, nice and simple.\nfunction removeItem$2(key, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        localStorage.removeItem(dbInfo.keyPrefix + key);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Set a key's value and run an optional callback once the value is set.\n// Unlike Gaia's implementation, the callback function is passed the value,\n// in case you want to operate on that value only after you're sure it\n// saved, or something like that.\nfunction setItem$2(key, value, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = self.ready().then(function () {\n        // Convert undefined values to null.\n        // https://github.com/mozilla/localForage/pull/42\n        if (value === undefined) {\n            value = null;\n        }\n\n        // Save the original value to pass to the callback.\n        var originalValue = value;\n\n        return new Promise$1(function (resolve, reject) {\n            var dbInfo = self._dbInfo;\n            dbInfo.serializer.serialize(value, function (value, error) {\n                if (error) {\n                    reject(error);\n                } else {\n                    try {\n                        localStorage.setItem(dbInfo.keyPrefix + key, value);\n                        resolve(originalValue);\n                    } catch (e) {\n                        // localStorage capacity exceeded.\n                        // TODO: Make this a specific error/event.\n                        if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {\n                            reject(e);\n                        }\n                        reject(e);\n                    }\n                }\n            });\n        });\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar localStorageWrapper = {\n    _driver: 'localStorageWrapper',\n    _initStorage: _initStorage$2,\n    // Default API, from Gaia/localStorage.\n    iterate: iterate$2,\n    getItem: getItem$2,\n    setItem: setItem$2,\n    removeItem: removeItem$2,\n    clear: clear$2,\n    length: length$2,\n    key: key$2,\n    keys: keys$2\n};\n\n// Custom drivers are stored here when `defineDriver()` is called.\n// They are shared across all instances of localForage.\nvar CustomDrivers = {};\n\nvar DriverType = {\n    INDEXEDDB: 'asyncStorage',\n    LOCALSTORAGE: 'localStorageWrapper',\n    WEBSQL: 'webSQLStorage'\n};\n\nvar DefaultDriverOrder = [DriverType.INDEXEDDB, DriverType.WEBSQL, DriverType.LOCALSTORAGE];\n\nvar LibraryMethods = ['clear', 'getItem', 'iterate', 'key', 'keys', 'length', 'removeItem', 'setItem'];\n\nvar DefaultConfig = {\n    description: '',\n    driver: DefaultDriverOrder.slice(),\n    name: 'localforage',\n    // Default DB size is _JUST UNDER_ 5MB, as it's the highest size\n    // we can use without a prompt.\n    size: 4980736,\n    storeName: 'keyvaluepairs',\n    version: 1.0\n};\n\nvar driverSupport = {};\n// Check to see if IndexedDB is available and if it is the latest\n// implementation; it's our preferred backend library. We use \"_spec_test\"\n// as the name of the database because it's not the one we'll operate on,\n// but it's useful to make sure its using the right spec.\n// See: https://github.com/mozilla/localForage/issues/128\ndriverSupport[DriverType.INDEXEDDB] = isIndexedDBValid();\n\ndriverSupport[DriverType.WEBSQL] = isWebSQLValid();\n\ndriverSupport[DriverType.LOCALSTORAGE] = isLocalStorageValid();\n\nvar isArray = Array.isArray || function (arg) {\n    return Object.prototype.toString.call(arg) === '[object Array]';\n};\n\nfunction callWhenReady(localForageInstance, libraryMethod) {\n    localForageInstance[libraryMethod] = function () {\n        var _args = arguments;\n        return localForageInstance.ready().then(function () {\n            return localForageInstance[libraryMethod].apply(localForageInstance, _args);\n        });\n    };\n}\n\nfunction extend() {\n    for (var i = 1; i < arguments.length; i++) {\n        var arg = arguments[i];\n\n        if (arg) {\n            for (var key in arg) {\n                if (arg.hasOwnProperty(key)) {\n                    if (isArray(arg[key])) {\n                        arguments[0][key] = arg[key].slice();\n                    } else {\n                        arguments[0][key] = arg[key];\n                    }\n                }\n            }\n        }\n    }\n\n    return arguments[0];\n}\n\nfunction isLibraryDriver(driverName) {\n    for (var driver in DriverType) {\n        if (DriverType.hasOwnProperty(driver) && DriverType[driver] === driverName) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nvar LocalForage = function () {\n    function LocalForage(options) {\n        _classCallCheck(this, LocalForage);\n\n        this.INDEXEDDB = DriverType.INDEXEDDB;\n        this.LOCALSTORAGE = DriverType.LOCALSTORAGE;\n        this.WEBSQL = DriverType.WEBSQL;\n\n        this._defaultConfig = extend({}, DefaultConfig);\n        this._config = extend({}, this._defaultConfig, options);\n        this._driverSet = null;\n        this._initDriver = null;\n        this._ready = false;\n        this._dbInfo = null;\n\n        this._wrapLibraryMethodsWithReady();\n        this.setDriver(this._config.driver)[\"catch\"](function () {});\n    }\n\n    // Set any config values for localForage; can be called anytime before\n    // the first API call (e.g. `getItem`, `setItem`).\n    // We loop through options so we don't overwrite existing config\n    // values.\n\n\n    LocalForage.prototype.config = function config(options) {\n        // If the options argument is an object, we use it to set values.\n        // Otherwise, we return either a specified config value or all\n        // config values.\n        if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {\n            // If localforage is ready and fully initialized, we can't set\n            // any new configuration values. Instead, we return an error.\n            if (this._ready) {\n                return new Error(\"Can't call config() after localforage \" + 'has been used.');\n            }\n\n            for (var i in options) {\n                if (i === 'storeName') {\n                    options[i] = options[i].replace(/\\W/g, '_');\n                }\n\n                if (i === 'version' && typeof options[i] !== 'number') {\n                    return new Error('Database version must be a number.');\n                }\n\n                this._config[i] = options[i];\n            }\n\n            // after all config options are set and\n            // the driver option is used, try setting it\n            if ('driver' in options && options.driver) {\n                return this.setDriver(this._config.driver);\n            }\n\n            return true;\n        } else if (typeof options === 'string') {\n            return this._config[options];\n        } else {\n            return this._config;\n        }\n    };\n\n    // Used to define a custom driver, shared across all instances of\n    // localForage.\n\n\n    LocalForage.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {\n        var promise = new Promise$1(function (resolve, reject) {\n            try {\n                var driverName = driverObject._driver;\n                var complianceError = new Error('Custom driver not compliant; see ' + 'https://mozilla.github.io/localForage/#definedriver');\n                var namingError = new Error('Custom driver name already in use: ' + driverObject._driver);\n\n                // A driver name should be defined and not overlap with the\n                // library-defined, default drivers.\n                if (!driverObject._driver) {\n                    reject(complianceError);\n                    return;\n                }\n                if (isLibraryDriver(driverObject._driver)) {\n                    reject(namingError);\n                    return;\n                }\n\n                var customDriverMethods = LibraryMethods.concat('_initStorage');\n                for (var i = 0; i < customDriverMethods.length; i++) {\n                    var customDriverMethod = customDriverMethods[i];\n                    if (!customDriverMethod || !driverObject[customDriverMethod] || typeof driverObject[customDriverMethod] !== 'function') {\n                        reject(complianceError);\n                        return;\n                    }\n                }\n\n                var supportPromise = Promise$1.resolve(true);\n                if ('_support' in driverObject) {\n                    if (driverObject._support && typeof driverObject._support === 'function') {\n                        supportPromise = driverObject._support();\n                    } else {\n                        supportPromise = Promise$1.resolve(!!driverObject._support);\n                    }\n                }\n\n                supportPromise.then(function (supportResult) {\n                    driverSupport[driverName] = supportResult;\n                    CustomDrivers[driverName] = driverObject;\n                    resolve();\n                }, reject);\n            } catch (e) {\n                reject(e);\n            }\n        });\n\n        executeTwoCallbacks(promise, callback, errorCallback);\n        return promise;\n    };\n\n    LocalForage.prototype.driver = function driver() {\n        return this._driver || null;\n    };\n\n    LocalForage.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {\n        var self = this;\n        var getDriverPromise = Promise$1.resolve().then(function () {\n            if (isLibraryDriver(driverName)) {\n                switch (driverName) {\n                    case self.INDEXEDDB:\n                        return asyncStorage;\n                    case self.LOCALSTORAGE:\n                        return localStorageWrapper;\n                    case self.WEBSQL:\n                        return webSQLStorage;\n                }\n            } else if (CustomDrivers[driverName]) {\n                return CustomDrivers[driverName];\n            } else {\n                throw new Error('Driver not found.');\n            }\n        });\n        executeTwoCallbacks(getDriverPromise, callback, errorCallback);\n        return getDriverPromise;\n    };\n\n    LocalForage.prototype.getSerializer = function getSerializer(callback) {\n        var serializerPromise = Promise$1.resolve(localforageSerializer);\n        executeTwoCallbacks(serializerPromise, callback);\n        return serializerPromise;\n    };\n\n    LocalForage.prototype.ready = function ready(callback) {\n        var self = this;\n\n        var promise = self._driverSet.then(function () {\n            if (self._ready === null) {\n                self._ready = self._initDriver();\n            }\n\n            return self._ready;\n        });\n\n        executeTwoCallbacks(promise, callback, callback);\n        return promise;\n    };\n\n    LocalForage.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {\n        var self = this;\n\n        if (!isArray(drivers)) {\n            drivers = [drivers];\n        }\n\n        var supportedDrivers = this._getSupportedDrivers(drivers);\n\n        function setDriverToConfig() {\n            self._config.driver = self.driver();\n        }\n\n        function extendSelfWithDriver(driver) {\n            self._extend(driver);\n            setDriverToConfig();\n\n            self._ready = self._initStorage(self._config);\n            return self._ready;\n        }\n\n        function initDriver(supportedDrivers) {\n            return function () {\n                var currentDriverIndex = 0;\n\n                function driverPromiseLoop() {\n                    while (currentDriverIndex < supportedDrivers.length) {\n                        var driverName = supportedDrivers[currentDriverIndex];\n                        currentDriverIndex++;\n\n                        self._dbInfo = null;\n                        self._ready = null;\n\n                        return self.getDriver(driverName).then(extendSelfWithDriver)[\"catch\"](driverPromiseLoop);\n                    }\n\n                    setDriverToConfig();\n                    var error = new Error('No available storage method found.');\n                    self._driverSet = Promise$1.reject(error);\n                    return self._driverSet;\n                }\n\n                return driverPromiseLoop();\n            };\n        }\n\n        // There might be a driver initialization in progress\n        // so wait for it to finish in order to avoid a possible\n        // race condition to set _dbInfo\n        var oldDriverSetDone = this._driverSet !== null ? this._driverSet[\"catch\"](function () {\n            return Promise$1.resolve();\n        }) : Promise$1.resolve();\n\n        this._driverSet = oldDriverSetDone.then(function () {\n            var driverName = supportedDrivers[0];\n            self._dbInfo = null;\n            self._ready = null;\n\n            return self.getDriver(driverName).then(function (driver) {\n                self._driver = driver._driver;\n                setDriverToConfig();\n                self._wrapLibraryMethodsWithReady();\n                self._initDriver = initDriver(supportedDrivers);\n            });\n        })[\"catch\"](function () {\n            setDriverToConfig();\n            var error = new Error('No available storage method found.');\n            self._driverSet = Promise$1.reject(error);\n            return self._driverSet;\n        });\n\n        executeTwoCallbacks(this._driverSet, callback, errorCallback);\n        return this._driverSet;\n    };\n\n    LocalForage.prototype.supports = function supports(driverName) {\n        return !!driverSupport[driverName];\n    };\n\n    LocalForage.prototype._extend = function _extend(libraryMethodsAndProperties) {\n        extend(this, libraryMethodsAndProperties);\n    };\n\n    LocalForage.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {\n        var supportedDrivers = [];\n        for (var i = 0, len = drivers.length; i < len; i++) {\n            var driverName = drivers[i];\n            if (this.supports(driverName)) {\n                supportedDrivers.push(driverName);\n            }\n        }\n        return supportedDrivers;\n    };\n\n    LocalForage.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {\n        // Add a stub for each driver API method that delays the call to the\n        // corresponding driver method until localForage is ready. These stubs\n        // will be replaced by the driver methods as soon as the driver is\n        // loaded, so there is no performance impact.\n        for (var i = 0; i < LibraryMethods.length; i++) {\n            callWhenReady(this, LibraryMethods[i]);\n        }\n    };\n\n    LocalForage.prototype.createInstance = function createInstance(options) {\n        return new LocalForage(options);\n    };\n\n    return LocalForage;\n}();\n\n// The actual localForage object that we expose as a module or via a\n// global. It's extended by pulling in one of our other libraries.\n\n\nvar localforage_js = new LocalForage();\n\nmodule.exports = localforage_js;\n\n},{\"3\":3}]},{},[4])(4)\n});\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(\"b+29\")))\n\n/***/ }),\n\n/***/ \"97Jz\":\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction t(t){function o(e,o){if(\"function\"==typeof t)return t(o.store.state,e)}return function(t){return function(n){function r(t,e){var r=this;n.call(this,t,e),this.state=o(t,e),this.handleStoreUpdate=function(){r.updateAnimId=setTimeout(function(){r.setState(o(r.props,r.context))})},e.store.on('*',this.handleStoreUpdate)}return n&&(r.__proto__=n),r.prototype=Object.create(n&&n.prototype),r.prototype.constructor=r,r.prototype.componentWillUnmount=function(){window.clearTimeout(this.updateAnimId),this.context.store.off('*',this.handleStoreUpdate)},r.prototype.render=function(o, n){return e.h(t,Object.assign({},Object.assign({},o),n,{emit:this.context.store.emit}))},r}(e.Component)}}Object.defineProperty(exports,\"__esModule\",{value:!0});var e=__webpack_require__(\"EF6w\"),o=function(t){function e(){t.apply(this,arguments)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getChildContext=function(){return{store:this.props.store}},e.prototype.render=function(t){return t.children[0]},e}(e.Component);exports.Provider=o,exports.connect=t;\n//# sourceMappingURL=preact-smitty.js.map\n\n\n/***/ }),\n\n/***/ \"EF6w\":\n/***/ (function(module, exports, __webpack_require__) {\n\n!function(global, factory) {\n     true ? factory(exports) : 'function' == typeof define && define.amd ? define([ 'exports' ], factory) : factory(global.preact = global.preact || {});\n}(this, function(exports) {\n    function VNode(nodeName, attributes, children) {\n        this.nodeName = nodeName;\n        this.attributes = attributes;\n        this.children = children;\n        this.key = attributes && attributes.key;\n    }\n    function h(nodeName, attributes) {\n        var children, lastSimple, child, simple, i;\n        for (i = arguments.length; i-- > 2; ) stack.push(arguments[i]);\n        if (attributes && attributes.children) {\n            if (!stack.length) stack.push(attributes.children);\n            delete attributes.children;\n        }\n        while (stack.length) if ((child = stack.pop()) instanceof Array) for (i = child.length; i--; ) stack.push(child[i]); else if (null != child && child !== !0 && child !== !1) {\n            if ('number' == typeof child) child = String(child);\n            simple = 'string' == typeof child;\n            if (simple && lastSimple) children[children.length - 1] += child; else {\n                (children || (children = [])).push(child);\n                lastSimple = simple;\n            }\n        }\n        var p = new VNode(nodeName, attributes || void 0, children || EMPTY_CHILDREN);\n        if (options.vnode) options.vnode(p);\n        return p;\n    }\n    function extend(obj, props) {\n        if (props) for (var i in props) obj[i] = props[i];\n        return obj;\n    }\n    function clone(obj) {\n        return extend({}, obj);\n    }\n    function delve(obj, key) {\n        for (var p = key.split('.'), i = 0; i < p.length && obj; i++) obj = obj[p[i]];\n        return obj;\n    }\n    function isFunction(obj) {\n        return 'function' == typeof obj;\n    }\n    function isString(obj) {\n        return 'string' == typeof obj;\n    }\n    function hashToClassName(c) {\n        var str = '';\n        for (var prop in c) if (c[prop]) {\n            if (str) str += ' ';\n            str += prop;\n        }\n        return str;\n    }\n    function cloneElement(vnode, props) {\n        return h(vnode.nodeName, extend(clone(vnode.attributes), props), arguments.length > 2 ? [].slice.call(arguments, 2) : vnode.children);\n    }\n    function createLinkedState(component, key, eventPath) {\n        var path = key.split('.');\n        return function(e) {\n            var t = e && e.target || this, state = {}, obj = state, v = isString(eventPath) ? delve(e, eventPath) : t.nodeName ? t.type.match(/^che|rad/) ? t.checked : t.value : e, i = 0;\n            for (;i < path.length - 1; i++) obj = obj[path[i]] || (obj[path[i]] = !i && component.state[path[i]] || {});\n            obj[path[i]] = v;\n            component.setState(state);\n        };\n    }\n    function enqueueRender(component) {\n        if (!component._dirty && (component._dirty = !0) && 1 == items.push(component)) (options.debounceRendering || defer)(rerender);\n    }\n    function rerender() {\n        var p, list = items;\n        items = [];\n        while (p = list.pop()) if (p._dirty) renderComponent(p);\n    }\n    function isFunctionalComponent(vnode) {\n        var nodeName = vnode && vnode.nodeName;\n        return nodeName && isFunction(nodeName) && !(nodeName.prototype && nodeName.prototype.render);\n    }\n    function buildFunctionalComponent(vnode, context) {\n        return vnode.nodeName(getNodeProps(vnode), context || EMPTY);\n    }\n    function isSameNodeType(node, vnode) {\n        if (isString(vnode)) return node instanceof Text;\n        if (isString(vnode.nodeName)) return !node._componentConstructor && isNamedNode(node, vnode.nodeName);\n        if (isFunction(vnode.nodeName)) return (node._componentConstructor ? node._componentConstructor === vnode.nodeName : !0) || isFunctionalComponent(vnode); else ;\n    }\n    function isNamedNode(node, nodeName) {\n        return node.normalizedNodeName === nodeName || toLowerCase(node.nodeName) === toLowerCase(nodeName);\n    }\n    function getNodeProps(vnode) {\n        var props = clone(vnode.attributes);\n        props.children = vnode.children;\n        var defaultProps = vnode.nodeName.defaultProps;\n        if (defaultProps) for (var i in defaultProps) if (void 0 === props[i]) props[i] = defaultProps[i];\n        return props;\n    }\n    function removeNode(node) {\n        var p = node.parentNode;\n        if (p) p.removeChild(node);\n    }\n    function setAccessor(node, name, old, value, isSvg) {\n        if ('className' === name) name = 'class';\n        if ('class' === name && value && 'object' == typeof value) value = hashToClassName(value);\n        if ('key' === name) ; else if ('class' === name && !isSvg) node.className = value || ''; else if ('style' === name) {\n            if (!value || isString(value) || isString(old)) node.style.cssText = value || '';\n            if (value && 'object' == typeof value) {\n                if (!isString(old)) for (var i in old) if (!(i in value)) node.style[i] = '';\n                for (var i in value) node.style[i] = 'number' == typeof value[i] && !NON_DIMENSION_PROPS[i] ? value[i] + 'px' : value[i];\n            }\n        } else if ('dangerouslySetInnerHTML' === name) {\n            if (value) node.innerHTML = value.__html || '';\n        } else if ('o' == name[0] && 'n' == name[1]) {\n            var l = node._listeners || (node._listeners = {});\n            name = toLowerCase(name.substring(2));\n            if (value) {\n                if (!l[name]) node.addEventListener(name, eventProxy, !!NON_BUBBLING_EVENTS[name]);\n            } else if (l[name]) node.removeEventListener(name, eventProxy, !!NON_BUBBLING_EVENTS[name]);\n            l[name] = value;\n        } else if ('list' !== name && 'type' !== name && !isSvg && name in node) {\n            setProperty(node, name, null == value ? '' : value);\n            if (null == value || value === !1) node.removeAttribute(name);\n        } else {\n            var ns = isSvg && name.match(/^xlink\\:?(.+)/);\n            if (null == value || value === !1) if (ns) node.removeAttributeNS('http://www.w3.org/1999/xlink', toLowerCase(ns[1])); else node.removeAttribute(name); else if ('object' != typeof value && !isFunction(value)) if (ns) node.setAttributeNS('http://www.w3.org/1999/xlink', toLowerCase(ns[1]), value); else node.setAttribute(name, value);\n        }\n    }\n    function setProperty(node, name, value) {\n        try {\n            node[name] = value;\n        } catch (e) {}\n    }\n    function eventProxy(e) {\n        return this._listeners[e.type](options.event && options.event(e) || e);\n    }\n    function collectNode(node) {\n        removeNode(node);\n        if (node instanceof Element) {\n            node._component = node._componentConstructor = null;\n            var _name = node.normalizedNodeName || toLowerCase(node.nodeName);\n            (nodes[_name] || (nodes[_name] = [])).push(node);\n        }\n    }\n    function createNode(nodeName, isSvg) {\n        var name = toLowerCase(nodeName), node = nodes[name] && nodes[name].pop() || (isSvg ? document.createElementNS('http://www.w3.org/2000/svg', nodeName) : document.createElement(nodeName));\n        node.normalizedNodeName = name;\n        return node;\n    }\n    function flushMounts() {\n        var c;\n        while (c = mounts.pop()) {\n            if (options.afterMount) options.afterMount(c);\n            if (c.componentDidMount) c.componentDidMount();\n        }\n    }\n    function diff(dom, vnode, context, mountAll, parent, componentRoot) {\n        if (!diffLevel++) {\n            isSvgMode = parent && 'undefined' != typeof parent.ownerSVGElement;\n            hydrating = dom && !(ATTR_KEY in dom);\n        }\n        var ret = idiff(dom, vnode, context, mountAll);\n        if (parent && ret.parentNode !== parent) parent.appendChild(ret);\n        if (!--diffLevel) {\n            hydrating = !1;\n            if (!componentRoot) flushMounts();\n        }\n        return ret;\n    }\n    function idiff(dom, vnode, context, mountAll) {\n        var ref = vnode && vnode.attributes && vnode.attributes.ref;\n        while (isFunctionalComponent(vnode)) vnode = buildFunctionalComponent(vnode, context);\n        if (null == vnode) vnode = '';\n        if (isString(vnode)) {\n            if (dom && dom instanceof Text && dom.parentNode) {\n                if (dom.nodeValue != vnode) dom.nodeValue = vnode;\n            } else {\n                if (dom) recollectNodeTree(dom);\n                dom = document.createTextNode(vnode);\n            }\n            return dom;\n        }\n        if (isFunction(vnode.nodeName)) return buildComponentFromVNode(dom, vnode, context, mountAll);\n        var out = dom, nodeName = String(vnode.nodeName), prevSvgMode = isSvgMode, vchildren = vnode.children;\n        isSvgMode = 'svg' === nodeName ? !0 : 'foreignObject' === nodeName ? !1 : isSvgMode;\n        if (!dom) out = createNode(nodeName, isSvgMode); else if (!isNamedNode(dom, nodeName)) {\n            out = createNode(nodeName, isSvgMode);\n            while (dom.firstChild) out.appendChild(dom.firstChild);\n            if (dom.parentNode) dom.parentNode.replaceChild(out, dom);\n            recollectNodeTree(dom);\n        }\n        var fc = out.firstChild, props = out[ATTR_KEY];\n        if (!props) {\n            out[ATTR_KEY] = props = {};\n            for (var a = out.attributes, i = a.length; i--; ) props[a[i].name] = a[i].value;\n        }\n        if (!hydrating && vchildren && 1 === vchildren.length && 'string' == typeof vchildren[0] && fc && fc instanceof Text && !fc.nextSibling) {\n            if (fc.nodeValue != vchildren[0]) fc.nodeValue = vchildren[0];\n        } else if (vchildren && vchildren.length || fc) innerDiffNode(out, vchildren, context, mountAll, !!props.dangerouslySetInnerHTML);\n        diffAttributes(out, vnode.attributes, props);\n        if (ref) (props.ref = ref)(out);\n        isSvgMode = prevSvgMode;\n        return out;\n    }\n    function innerDiffNode(dom, vchildren, context, mountAll, absorb) {\n        var j, c, vchild, child, originalChildren = dom.childNodes, children = [], keyed = {}, keyedLen = 0, min = 0, len = originalChildren.length, childrenLen = 0, vlen = vchildren && vchildren.length;\n        if (len) for (var i = 0; i < len; i++) {\n            var _child = originalChildren[i], props = _child[ATTR_KEY], key = vlen ? (c = _child._component) ? c.__key : props ? props.key : null : null;\n            if (null != key) {\n                keyedLen++;\n                keyed[key] = _child;\n            } else if (hydrating || absorb || props || _child instanceof Text) children[childrenLen++] = _child;\n        }\n        if (vlen) for (var i = 0; i < vlen; i++) {\n            vchild = vchildren[i];\n            child = null;\n            var key = vchild.key;\n            if (null != key) {\n                if (keyedLen && key in keyed) {\n                    child = keyed[key];\n                    keyed[key] = void 0;\n                    keyedLen--;\n                }\n            } else if (!child && min < childrenLen) for (j = min; j < childrenLen; j++) {\n                c = children[j];\n                if (c && isSameNodeType(c, vchild)) {\n                    child = c;\n                    children[j] = void 0;\n                    if (j === childrenLen - 1) childrenLen--;\n                    if (j === min) min++;\n                    break;\n                }\n            }\n            child = idiff(child, vchild, context, mountAll);\n            if (child && child !== dom) if (i >= len) dom.appendChild(child); else if (child !== originalChildren[i]) {\n                if (child === originalChildren[i + 1]) removeNode(originalChildren[i]);\n                dom.insertBefore(child, originalChildren[i] || null);\n            }\n        }\n        if (keyedLen) for (var i in keyed) if (keyed[i]) recollectNodeTree(keyed[i]);\n        while (min <= childrenLen) {\n            child = children[childrenLen--];\n            if (child) recollectNodeTree(child);\n        }\n    }\n    function recollectNodeTree(node, unmountOnly) {\n        var component = node._component;\n        if (component) unmountComponent(component, !unmountOnly); else {\n            if (node[ATTR_KEY] && node[ATTR_KEY].ref) node[ATTR_KEY].ref(null);\n            if (!unmountOnly) collectNode(node);\n            var c;\n            while (c = node.lastChild) recollectNodeTree(c, unmountOnly);\n        }\n    }\n    function diffAttributes(dom, attrs, old) {\n        var name;\n        for (name in old) if (!(attrs && name in attrs) && null != old[name]) setAccessor(dom, name, old[name], old[name] = void 0, isSvgMode);\n        if (attrs) for (name in attrs) if (!('children' === name || 'innerHTML' === name || name in old && attrs[name] === ('value' === name || 'checked' === name ? dom[name] : old[name]))) setAccessor(dom, name, old[name], old[name] = attrs[name], isSvgMode);\n    }\n    function collectComponent(component) {\n        var name = component.constructor.name, list = components[name];\n        if (list) list.push(component); else components[name] = [ component ];\n    }\n    function createComponent(Ctor, props, context) {\n        var inst = new Ctor(props, context), list = components[Ctor.name];\n        Component.call(inst, props, context);\n        if (list) for (var i = list.length; i--; ) if (list[i].constructor === Ctor) {\n            inst.nextBase = list[i].nextBase;\n            list.splice(i, 1);\n            break;\n        }\n        return inst;\n    }\n    function setComponentProps(component, props, opts, context, mountAll) {\n        if (!component._disable) {\n            component._disable = !0;\n            if (component.__ref = props.ref) delete props.ref;\n            if (component.__key = props.key) delete props.key;\n            if (!component.base || mountAll) {\n                if (component.componentWillMount) component.componentWillMount();\n            } else if (component.componentWillReceiveProps) component.componentWillReceiveProps(props, context);\n            if (context && context !== component.context) {\n                if (!component.prevContext) component.prevContext = component.context;\n                component.context = context;\n            }\n            if (!component.prevProps) component.prevProps = component.props;\n            component.props = props;\n            component._disable = !1;\n            if (0 !== opts) if (1 === opts || options.syncComponentUpdates !== !1 || !component.base) renderComponent(component, 1, mountAll); else enqueueRender(component);\n            if (component.__ref) component.__ref(component);\n        }\n    }\n    function renderComponent(component, opts, mountAll, isChild) {\n        if (!component._disable) {\n            var skip, rendered, inst, cbase, props = component.props, state = component.state, context = component.context, previousProps = component.prevProps || props, previousState = component.prevState || state, previousContext = component.prevContext || context, isUpdate = component.base, nextBase = component.nextBase, initialBase = isUpdate || nextBase, initialChildComponent = component._component;\n            if (isUpdate) {\n                component.props = previousProps;\n                component.state = previousState;\n                component.context = previousContext;\n                if (2 !== opts && component.shouldComponentUpdate && component.shouldComponentUpdate(props, state, context) === !1) skip = !0; else if (component.componentWillUpdate) component.componentWillUpdate(props, state, context);\n                component.props = props;\n                component.state = state;\n                component.context = context;\n            }\n            component.prevProps = component.prevState = component.prevContext = component.nextBase = null;\n            component._dirty = !1;\n            if (!skip) {\n                if (component.render) rendered = component.render(props, state, context);\n                if (component.getChildContext) context = extend(clone(context), component.getChildContext());\n                while (isFunctionalComponent(rendered)) rendered = buildFunctionalComponent(rendered, context);\n                var toUnmount, base, childComponent = rendered && rendered.nodeName;\n                if (isFunction(childComponent)) {\n                    var childProps = getNodeProps(rendered);\n                    inst = initialChildComponent;\n                    if (inst && inst.constructor === childComponent && childProps.key == inst.__key) setComponentProps(inst, childProps, 1, context); else {\n                        toUnmount = inst;\n                        inst = createComponent(childComponent, childProps, context);\n                        inst.nextBase = inst.nextBase || nextBase;\n                        inst._parentComponent = component;\n                        component._component = inst;\n                        setComponentProps(inst, childProps, 0, context);\n                        renderComponent(inst, 1, mountAll, !0);\n                    }\n                    base = inst.base;\n                } else {\n                    cbase = initialBase;\n                    toUnmount = initialChildComponent;\n                    if (toUnmount) cbase = component._component = null;\n                    if (initialBase || 1 === opts) {\n                        if (cbase) cbase._component = null;\n                        base = diff(cbase, rendered, context, mountAll || !isUpdate, initialBase && initialBase.parentNode, !0);\n                    }\n                }\n                if (initialBase && base !== initialBase && inst !== initialChildComponent) {\n                    var baseParent = initialBase.parentNode;\n                    if (baseParent && base !== baseParent) {\n                        baseParent.replaceChild(base, initialBase);\n                        if (!toUnmount) {\n                            initialBase._component = null;\n                            recollectNodeTree(initialBase);\n                        }\n                    }\n                }\n                if (toUnmount) unmountComponent(toUnmount, base !== initialBase);\n                component.base = base;\n                if (base && !isChild) {\n                    var componentRef = component, t = component;\n                    while (t = t._parentComponent) (componentRef = t).base = base;\n                    base._component = componentRef;\n                    base._componentConstructor = componentRef.constructor;\n                }\n            }\n            if (!isUpdate || mountAll) mounts.unshift(component); else if (!skip) {\n                if (component.componentDidUpdate) component.componentDidUpdate(previousProps, previousState, previousContext);\n                if (options.afterUpdate) options.afterUpdate(component);\n            }\n            var fn, cb = component._renderCallbacks;\n            if (cb) while (fn = cb.pop()) fn.call(component);\n            if (!diffLevel && !isChild) flushMounts();\n        }\n    }\n    function buildComponentFromVNode(dom, vnode, context, mountAll) {\n        var c = dom && dom._component, originalComponent = c, oldDom = dom, isDirectOwner = c && dom._componentConstructor === vnode.nodeName, isOwner = isDirectOwner, props = getNodeProps(vnode);\n        while (c && !isOwner && (c = c._parentComponent)) isOwner = c.constructor === vnode.nodeName;\n        if (c && isOwner && (!mountAll || c._component)) {\n            setComponentProps(c, props, 3, context, mountAll);\n            dom = c.base;\n        } else {\n            if (originalComponent && !isDirectOwner) {\n                unmountComponent(originalComponent, !0);\n                dom = oldDom = null;\n            }\n            c = createComponent(vnode.nodeName, props, context);\n            if (dom && !c.nextBase) {\n                c.nextBase = dom;\n                oldDom = null;\n            }\n            setComponentProps(c, props, 1, context, mountAll);\n            dom = c.base;\n            if (oldDom && dom !== oldDom) {\n                oldDom._component = null;\n                recollectNodeTree(oldDom);\n            }\n        }\n        return dom;\n    }\n    function unmountComponent(component, remove) {\n        if (options.beforeUnmount) options.beforeUnmount(component);\n        var base = component.base;\n        component._disable = !0;\n        if (component.componentWillUnmount) component.componentWillUnmount();\n        component.base = null;\n        var inner = component._component;\n        if (inner) unmountComponent(inner, remove); else if (base) {\n            if (base[ATTR_KEY] && base[ATTR_KEY].ref) base[ATTR_KEY].ref(null);\n            component.nextBase = base;\n            if (remove) {\n                removeNode(base);\n                collectComponent(component);\n            }\n            var c;\n            while (c = base.lastChild) recollectNodeTree(c, !remove);\n        }\n        if (component.__ref) component.__ref(null);\n        if (component.componentDidUnmount) component.componentDidUnmount();\n    }\n    function Component(props, context) {\n        this._dirty = !0;\n        this.context = context;\n        this.props = props;\n        if (!this.state) this.state = {};\n    }\n    function render(vnode, parent, merge) {\n        return diff(merge, vnode, {}, !1, parent);\n    }\n    var options = {};\n    var stack = [];\n    var EMPTY_CHILDREN = [];\n    var lcCache = {};\n    var toLowerCase = function(s) {\n        return lcCache[s] || (lcCache[s] = s.toLowerCase());\n    };\n    var resolved = 'undefined' != typeof Promise && Promise.resolve();\n    var defer = resolved ? function(f) {\n        resolved.then(f);\n    } : setTimeout;\n    var EMPTY = {};\n    var ATTR_KEY = 'undefined' != typeof Symbol ? Symbol.for('preactattr') : '__preactattr_';\n    var NON_DIMENSION_PROPS = {\n        boxFlex: 1,\n        boxFlexGroup: 1,\n        columnCount: 1,\n        fillOpacity: 1,\n        flex: 1,\n        flexGrow: 1,\n        flexPositive: 1,\n        flexShrink: 1,\n        flexNegative: 1,\n        fontWeight: 1,\n        lineClamp: 1,\n        lineHeight: 1,\n        opacity: 1,\n        order: 1,\n        orphans: 1,\n        strokeOpacity: 1,\n        widows: 1,\n        zIndex: 1,\n        zoom: 1\n    };\n    var NON_BUBBLING_EVENTS = {\n        blur: 1,\n        error: 1,\n        focus: 1,\n        load: 1,\n        resize: 1,\n        scroll: 1\n    };\n    var items = [];\n    var nodes = {};\n    var mounts = [];\n    var diffLevel = 0;\n    var isSvgMode = !1;\n    var hydrating = !1;\n    var components = {};\n    extend(Component.prototype, {\n        linkState: function(key, eventPath) {\n            var c = this._linkedStates || (this._linkedStates = {});\n            return c[key + eventPath] || (c[key + eventPath] = createLinkedState(this, key, eventPath));\n        },\n        setState: function(state, callback) {\n            var s = this.state;\n            if (!this.prevState) this.prevState = clone(s);\n            extend(s, isFunction(state) ? state(s, this.props) : state);\n            if (callback) (this._renderCallbacks = this._renderCallbacks || []).push(callback);\n            enqueueRender(this);\n        },\n        forceUpdate: function() {\n            renderComponent(this, 2);\n        },\n        render: function() {}\n    });\n    exports.h = h;\n    exports.cloneElement = cloneElement;\n    exports.Component = Component;\n    exports.render = render;\n    exports.rerender = rerender;\n    exports.options = options;\n});\n//# sourceMappingURL=preact.js.map\n\n/***/ }),\n\n/***/ \"NNls\":\n/***/ (function(module, exports) {\n\n// removed by extract-text-webpack-plugin\n\n/***/ }),\n\n/***/ \"b+29\":\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n\n/***/ \"ctQG\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_preact__ = __webpack_require__(\"EF6w\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_preact___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_preact__);\n// eslint-disable-next-line no-unused-vars\n/** @jsx h */\n\n\nvar root = void 0;\nfunction run() {\n  var Root = __webpack_require__(\"jFIt\").default;\n  root = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"render\"])(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_preact__[\"h\"])(Root, { test: 'foo' }), document.querySelector('#demo'), root);\n}\n\nrun();\n\nif (false) {\n  // Whenever a new version of App.js is available\n  module.hot.accept('./App', function () {\n    // Require the new version and render it instead\n    run();\n  });\n}\n\n/***/ }),\n\n/***/ \"jFIt\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__style_css__ = __webpack_require__(\"NNls\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__style_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__style_css__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_preact__ = __webpack_require__(\"EF6w\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_preact___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_preact__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_preact_smitty__ = __webpack_require__(\"97Jz\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_preact_smitty___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_preact_smitty__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__src__ = __webpack_require__(\"lVK7\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_raw_loader_App_js__ = __webpack_require__(\"+iyJ\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_raw_loader_App_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_raw_loader_App_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_localforage__ = __webpack_require__(\"22C0\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_localforage___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_localforage__);\nvar _this = this,\n    _store$handleActions;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\n/** @jsx h */\n\n\n\n\n\n\n\n__WEBPACK_IMPORTED_MODULE_5_localforage___default.a.config({ name: 'smitty_photo_booth' });\n\nvar pp = function pp(obj) {\n  return JSON.stringify(obj, null, 2);\n};\nvar getId = function getId() {\n  return new Date().toString();\n};\n\nvar store = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__src__[\"a\" /* createStore */])({\n  camera: {\n    recording: false,\n    stream: new window.MediaStream(),\n    images: []\n  },\n  ui: {\n    selectedImageId: null\n  }\n});\n\nstore.createActions({\n  startMediaStream: function startMediaStream(constraints) {\n    return function () {\n      var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(store) {\n        var stream;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                _context.next = 3;\n                return navigator.mediaDevices.getUserMedia(constraints);\n\n              case 3:\n                stream = _context.sent;\n\n                store.actions.mediaStreamSuccess(stream);\n                _context.next = 10;\n                break;\n\n              case 7:\n                _context.prev = 7;\n                _context.t0 = _context['catch'](0);\n\n                store.actions.mediaStreamError(_context.t0);\n\n              case 10:\n              case 'end':\n                return _context.stop();\n            }\n          }\n        }, _callee, _this, [[0, 7]]);\n      }));\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n  },\n  mediaStreamSuccess: 'camera/STREAM_SUCCESS',\n  mediaStreamError: 'camera/STREAM_ERROR',\n  addImages: 'camera/ADD_IMAGES',\n  saveImage: function saveImage(url) {\n    return function (store) {\n      var id = getId();\n      var image = { id: id, url: url };\n      store.actions.addImages([image]);\n\n      __WEBPACK_IMPORTED_MODULE_5_localforage___default.a.getItem('images').then(function (images) {\n        images.push(image);\n        __WEBPACK_IMPORTED_MODULE_5_localforage___default.a.setItem('images', images);\n      }).catch(function (err) {\n        return console.log('Could not save image to db', err);\n      });\n    };\n  },\n  selectImage: function selectImage(id) {\n    return function (store) {\n      store.actions.setSelectedImageById(id);\n      window.history.pushState({}, '', id || '/');\n    };\n  },\n  setSelectedImageById: 'ui/SELECT_IMAGE'\n});\n\nstore.handleActions((_store$handleActions = {}, _store$handleActions[store.actions.mediaStreamSuccess] = function (state, stream) {\n  state.camera.stream = stream;\n}, _store$handleActions[store.actions.mediaStreamError] = function (state, error) {\n  state.camera.streamError = error;\n}, _store$handleActions[store.actions.addImages] = function (state, images) {\n  state.camera.images = state.camera.images.concat(images);\n}, _store$handleActions[store.actions.setSelectedImageById] = function (state, imageId) {\n  state.ui.selectedImageId = imageId;\n}, _store$handleActions));\n\n__WEBPACK_IMPORTED_MODULE_5_localforage___default.a.getItem('images').then(function (images) {\n  if (images) {\n    store.actions.addImages(images);\n  } else {\n    __WEBPACK_IMPORTED_MODULE_5_localforage___default.a.setItem('images', []);\n  }\n});\n\nif (window.location.pathname !== '/') {\n  store.actions.setSelectedImageById(decodeURI(window.location.pathname).split('/')[1]);\n}\n\nwindow.onpopstate = function (event) {\n  store.actions.setSelectedImageById(decodeURI(window.location.pathname).split('/')[1]);\n};\n\nvar Camera = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_preact_smitty__[\"connect\"])(function (state) {\n  return {\n    stream: state.camera.stream,\n    streamError: state.camera.streamError\n  };\n})(function (_Component) {\n  _inherits(Camera, _Component);\n\n  function Camera() {\n    var _temp, _this2, _ret;\n\n    _classCallCheck(this, Camera);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this2 = _possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this2), _this2.video = null, _this2.canvas = null, _this2.handleClick = function () {\n      var canvas = _this2.canvas;\n      var ctx = canvas.getContext('2d');\n      var width = _this2.video.videoWidth;\n      var height = _this2.video.videoHeight;\n      canvas.width = width;\n      canvas.height = height;\n      ctx.fillRect(0, 0, width, height);\n      ctx.drawImage(_this2.video, 0, 0, width, height);\n\n      _this2.context.store.actions.saveImage(canvas.toDataURL('image/webp'));\n    }, _temp), _possibleConstructorReturn(_this2, _ret);\n  }\n\n  Camera.prototype.componentDidMount = function componentDidMount() {\n    this.context.store.actions.startMediaStream({\n      audio: false,\n      video: true\n    });\n  };\n\n  Camera.prototype.render = function render(_ref2) {\n    var _this3 = this;\n\n    var streamError = _ref2.streamError;\n\n    return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_preact__[\"h\"])(\n      'div',\n      {\n        style: {\n          paddingTop: 16,\n          paddingRight: 16,\n          paddingBottom: 16,\n          paddingLeft: 16\n        }\n      },\n      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_preact__[\"h\"])(\n        'h3',\n        {\n          style: {\n            height: streamError ? 24 : 0,\n            lineHeight: '1.2',\n            marginBottom: 16,\n            textAlign: 'center',\n            color: '#ff6b6b',\n            opacity: streamError ? 1 : 0,\n            transition: 'all 250ms ease-in-out'\n          }\n        },\n        streamError ? streamError.name : ''\n      ),\n      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_preact__[\"h\"])('video', {\n        ref: function ref(node) {\n          _this3.video = node;\n        },\n        style: {\n          width: '100%',\n          maxHeight: 'calc(50vh - 16px)',\n          background: '#212529',\n          cursor: 'pointer'\n        },\n        src: window.URL ? window.URL.createObjectURL(this.props.stream) : this.props.stream,\n        autoplay: true,\n        muted: true,\n        onClick: this.handleClick\n      }),\n      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_preact__[\"h\"])('canvas', {\n        ref: function ref(node) {\n          _this3.canvas = node;\n        },\n        style: { display: 'none' }\n      }),\n      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_preact__[\"h\"])(\n        'div',\n        {\n          style: {\n            display: 'flex',\n            alignItems: 'center',\n            justifyContent: 'center',\n            width: '100%',\n            marginTop: 16,\n            marginBottom: 16\n          }\n        },\n        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_preact__[\"h\"])(\n          'button',\n          {\n            style: {\n              paddingTop: 8,\n              paddingRight: 16,\n              paddingBottom: 8,\n              paddingLeft: 16,\n              margin: '0 auto',\n              fontSize: 20,\n              lineHeight: '1.6',\n              color: '#adb5bd',\n              background: '#343a40',\n              border: 'none',\n              outline: 'none',\n              boxShadow: 'none',\n              borderRadius: 5,\n              cursor: 'pointer',\n              opacity: streamError ? 0 : 1,\n              transition: 'all 250ms ease-in-out'\n            },\n            disabled: streamError,\n            type: 'button',\n            onClick: this.handleClick\n          },\n          'Take Picture'\n        )\n      )\n    );\n  };\n\n  return Camera;\n}(__WEBPACK_IMPORTED_MODULE_1_preact__[\"Component\"]));\n\nvar ImageList = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_preact_smitty__[\"connect\"])(function (state) {\n  return {\n    images: state.camera.images,\n    selectedImageId: state.ui.selectedImageId\n  };\n})(function ImageList(_ref3, _ref4) {\n  var images = _ref3.images,\n      selectedImageId = _ref3.selectedImageId;\n  var store = _ref4.store;\n\n  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_preact__[\"h\"])(\n    'div',\n    {\n      style: {\n        display: 'flex',\n        flexFlow: 'wrap'\n      }\n    },\n    images.map(function (image, i) {\n      return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_preact__[\"h\"])(Image, {\n        key: image.id,\n        image: image,\n        index: i,\n        selected: image.id === selectedImageId,\n        onClick: function onClick() {\n          store.actions.selectImage(image.id === selectedImageId ? null : image.id);\n        }\n      });\n    })\n  );\n});\n\nfunction Image(_ref5) {\n  var image = _ref5.image,\n      index = _ref5.index,\n      _onClick = _ref5.onClick,\n      selected = _ref5.selected;\n\n  var wrapperStyles = selected ? {\n    position: 'fixed',\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0,\n    width: '100%',\n    height: '100%',\n    display: 'flex',\n    alignItems: 'center',\n    justifyContent: 'center',\n    background: '#f8f9fa',\n    zIndex: 10\n  } : {\n    position: 'relative',\n    flex: '0 1 auto',\n    width: 'calc(33% - 4px)',\n    order: index * -1,\n    paddingTop: 2,\n    paddingRight: 2,\n    paddingBottom: 0,\n    paddingLeft: 2\n  };\n\n  var imgStyles = selected ? { width: '90%', maxHeight: '90%', borderRadius: 8 } : { width: '100%', borderRadius: 4 };\n\n  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_preact__[\"h\"])(\n    'a',\n    {\n      style: wrapperStyles,\n      href: image.url,\n      target: '_blank',\n      onClick: function onClick(e) {\n        e.preventDefault();\n        _onClick();\n      }\n    },\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_preact__[\"h\"])('img', { src: image.url, style: imgStyles })\n  );\n}\n\nfunction GithubRibbon() {\n  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_preact__[\"h\"])('iframe', {\n    src: 'https://ghbtns.com/github-btn.html?user=tkh44&repo=smitty&type=star&count=true&size=large',\n    frameborder: '0',\n    scrolling: '0',\n    width: '160px',\n    height: '30px',\n    style: { marginLeft: 'auto' }\n  });\n}\n\nvar App = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2_preact_smitty__[\"connect\"])(function (state) {\n  return state;\n})(function (props) {\n  var _ref6;\n\n  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_preact__[\"h\"])(\n    'div',\n    { style: { display: 'flex' } },\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_preact__[\"h\"])(\n      'div',\n      {\n        style: (_ref6 = {\n          flex: '1 0 50%',\n          height: '100vh',\n          background: '#212529',\n          overflow: 'auto',\n          WebkitOverflowScrolling: 'touch'\n        }, _ref6['background'] = props.camera.streamError ? '#f8f9fa' : '#212529', _ref6.cursor = 'pointer', _ref6.transition = 'all 250ms ease-in-out', _ref6)\n      },\n      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_preact__[\"h\"])(Camera, null)\n    ),\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_preact__[\"h\"])(\n      'div',\n      {\n        style: {\n          flex: '1 0 50%',\n          height: '100vh',\n          background: '#f8f9fa',\n          borderLeft: '1px solid #dee2e6',\n          overflow: 'auto',\n          WebkitOverflowScrolling: 'touch'\n        }\n      },\n      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_preact__[\"h\"])(\n        'div',\n        {\n          style: {\n            display: 'flex',\n            alignItems: 'center',\n            borderBottom: '1px solid #dee2e6',\n            paddingRight: 8,\n            paddingLeft: 8\n          }\n        },\n        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_preact__[\"h\"])(\n          'h2',\n          null,\n          'Smitty Photo Booth Demo'\n        ),\n        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_preact__[\"h\"])(\n          'a',\n          {\n            href: 'https://github.com/tkh44/smitty/tree/master/demo/src',\n            style: { fontSize: '1rem', color: '#329af0', marginLeft: 8 },\n            target: '_blank'\n          },\n          'source'\n        ),\n        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_preact__[\"h\"])(GithubRibbon, null)\n      ),\n      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_preact__[\"h\"])(ImageList, null)\n    )\n  );\n});\n\nvar Root = function Root(props) {\n  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_preact__[\"h\"])(\n    __WEBPACK_IMPORTED_MODULE_2_preact_smitty__[\"Provider\"],\n    { store: store },\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1_preact__[\"h\"])(App, null)\n  );\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = Root;\n\n/***/ }),\n\n/***/ \"lVK7\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_mitt__ = __webpack_require__(\"tNdy\");\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_mitt___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_mitt__);\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = createStore;\n\n\nfunction Store(initialState) {\n  var _state = initialState;\n  this.actions = {};\n  this.events = __WEBPACK_IMPORTED_MODULE_0_mitt___default()();\n  this.on = this.events.on;\n  this.off = this.events.off;\n  this.emit = this.emit.bind(this);\n  this.handleActions = this.handleActions.bind(this);\n\n  Object.defineProperty(this, 'state', {\n    get: function get() {\n      return _state;\n    },\n    set: function set(value) {\n      _state = value;\n    }\n  });\n}\n\nObject.assign(Store.prototype, {\n  emit: function emit(type, payload) {\n    if (typeof type === 'function') return type(this);\n    this.events.emit(type, payload);\n  },\n  createActions: function createActions(actionMap) {\n    var _this = this;\n\n    var _loop = function _loop(creatorName) {\n      var type = actionMap[creatorName];\n      var actionCreator = void 0;\n      if (typeof type === 'function') {\n        actionCreator = function actionCreator(payload) {\n          return _this.emit(type(payload));\n        };\n      } else {\n        actionCreator = function actionCreator(payload) {\n          return _this.emit(type, payload);\n        };\n        actionCreator.toString = function () {\n          return type.toString();\n        };\n      }\n      _this.actions[creatorName] = actionCreator;\n    };\n\n    for (var creatorName in actionMap) {\n      _loop(creatorName);\n    }\n  },\n  handleActions: function handleActions(handlerMap) {\n    var _this2 = this;\n\n    var _loop2 = function _loop2(_type) {\n      var handler = function handler(eventType, e) {\n        if (eventType.substring(0, 8) === '$$store:') return;\n        _this2.state = handlerMap[_type](_this2.state, e, eventType) || _this2.state;\n        _this2.events.emit('$$store:state:change', _this2.state);\n      };\n      if (_type !== '*') {\n        handler = handler.bind(null, _type);\n      }\n      _this2.events.on(_type, handler);\n    };\n\n    for (var _type in handlerMap) {\n      _loop2(_type);\n    }\n  }\n});\n\nfunction createStore(initialState) {\n  return new Store(initialState);\n}\n\n/***/ }),\n\n/***/ \"tNdy\":\n/***/ (function(module, exports) {\n\nfunction n(n){return n=n||Object.create(null),{on:function(t,o){(n[t]||(n[t]=[])).push(o)},off:function(t,o){var u=n[t]||(n[t]=[]);u.splice(u.indexOf(o)>>>0,1)},emit:function(t,o){(n[t]||[]).map(function(n){n(o)}),(n[\"*\"]||[]).map(function(n){n(t,o)})}}}module.exports=n;\n//# sourceMappingURL=mitt.js.map\n\n/***/ })\n\n},[0]);\n\n\n// WEBPACK FOOTER //\n// demo.f172fc41.js","module.exports = \"var _this = this,\\n    _store$handleActions;\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\\\"next\\\", value); }, function (err) { step(\\\"throw\\\", err); }); } } return step(\\\"next\\\"); }); }; }\\n\\n/** @jsx h */\\nimport './style.css';\\nimport { render, h, Component } from 'preact';\\nimport { Provider, connect } from 'preact-smitty';\\nimport { createStore } from '../../src';\\nimport source from 'raw-loader!./App.js';\\nimport localforage from 'localforage';\\n\\nlocalforage.config({ name: 'smitty_photo_booth' });\\n\\nvar pp = function pp(obj) {\\n  return JSON.stringify(obj, null, 2);\\n};\\nvar getId = function getId() {\\n  return new Date().toString();\\n};\\n\\nvar store = createStore({\\n  camera: {\\n    recording: false,\\n    stream: new window.MediaStream(),\\n    images: []\\n  },\\n  ui: {\\n    selectedImageId: null\\n  }\\n});\\n\\nstore.createActions({\\n  startMediaStream: function startMediaStream(constraints) {\\n    return function () {\\n      var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(store) {\\n        var stream;\\n        return regeneratorRuntime.wrap(function _callee$(_context) {\\n          while (1) {\\n            switch (_context.prev = _context.next) {\\n              case 0:\\n                _context.prev = 0;\\n                _context.next = 3;\\n                return navigator.mediaDevices.getUserMedia(constraints);\\n\\n              case 3:\\n                stream = _context.sent;\\n\\n                store.actions.mediaStreamSuccess(stream);\\n                _context.next = 10;\\n                break;\\n\\n              case 7:\\n                _context.prev = 7;\\n                _context.t0 = _context['catch'](0);\\n\\n                store.actions.mediaStreamError(_context.t0);\\n\\n              case 10:\\n              case 'end':\\n                return _context.stop();\\n            }\\n          }\\n        }, _callee, _this, [[0, 7]]);\\n      }));\\n\\n      return function (_x) {\\n        return _ref.apply(this, arguments);\\n      };\\n    }();\\n  },\\n  mediaStreamSuccess: 'camera/STREAM_SUCCESS',\\n  mediaStreamError: 'camera/STREAM_ERROR',\\n  addImages: 'camera/ADD_IMAGES',\\n  saveImage: function saveImage(url) {\\n    return function (store) {\\n      var id = getId();\\n      var image = { id: id, url: url };\\n      store.actions.addImages([image]);\\n\\n      localforage.getItem('images').then(function (images) {\\n        images.push(image);\\n        localforage.setItem('images', images);\\n      }).catch(function (err) {\\n        return console.log('Could not save image to db', err);\\n      });\\n    };\\n  },\\n  selectImage: function selectImage(id) {\\n    return function (store) {\\n      store.actions.setSelectedImageById(id);\\n      window.history.pushState({}, '', id || '/');\\n    };\\n  },\\n  setSelectedImageById: 'ui/SELECT_IMAGE'\\n});\\n\\nstore.handleActions((_store$handleActions = {}, _store$handleActions[store.actions.mediaStreamSuccess] = function (state, stream) {\\n  state.camera.stream = stream;\\n}, _store$handleActions[store.actions.mediaStreamError] = function (state, error) {\\n  state.camera.streamError = error;\\n}, _store$handleActions[store.actions.addImages] = function (state, images) {\\n  state.camera.images = state.camera.images.concat(images);\\n}, _store$handleActions[store.actions.setSelectedImageById] = function (state, imageId) {\\n  state.ui.selectedImageId = imageId;\\n}, _store$handleActions));\\n\\nlocalforage.getItem('images').then(function (images) {\\n  if (images) {\\n    store.actions.addImages(images);\\n  } else {\\n    localforage.setItem('images', []);\\n  }\\n});\\n\\nif (window.location.pathname !== '/') {\\n  store.actions.setSelectedImageById(decodeURI(window.location.pathname).split('/')[1]);\\n}\\n\\nwindow.onpopstate = function (event) {\\n  store.actions.setSelectedImageById(decodeURI(window.location.pathname).split('/')[1]);\\n};\\n\\nvar Camera = connect(function (state) {\\n  return {\\n    stream: state.camera.stream,\\n    streamError: state.camera.streamError\\n  };\\n})(function (_Component) {\\n  _inherits(Camera, _Component);\\n\\n  function Camera() {\\n    var _temp, _this2, _ret;\\n\\n    _classCallCheck(this, Camera);\\n\\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\\n      args[_key] = arguments[_key];\\n    }\\n\\n    return _ret = (_temp = (_this2 = _possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this2), _this2.video = null, _this2.canvas = null, _this2.handleClick = function () {\\n      var canvas = _this2.canvas;\\n      var ctx = canvas.getContext('2d');\\n      var width = _this2.video.videoWidth;\\n      var height = _this2.video.videoHeight;\\n      canvas.width = width;\\n      canvas.height = height;\\n      ctx.fillRect(0, 0, width, height);\\n      ctx.drawImage(_this2.video, 0, 0, width, height);\\n\\n      _this2.context.store.actions.saveImage(canvas.toDataURL('image/webp'));\\n    }, _temp), _possibleConstructorReturn(_this2, _ret);\\n  }\\n\\n  Camera.prototype.componentDidMount = function componentDidMount() {\\n    this.context.store.actions.startMediaStream({\\n      audio: false,\\n      video: true\\n    });\\n  };\\n\\n  Camera.prototype.render = function render(_ref2) {\\n    var _this3 = this;\\n\\n    var streamError = _ref2.streamError;\\n\\n    return h(\\n      'div',\\n      {\\n        style: {\\n          paddingTop: 16,\\n          paddingRight: 16,\\n          paddingBottom: 16,\\n          paddingLeft: 16\\n        }\\n      },\\n      h(\\n        'h3',\\n        {\\n          style: {\\n            height: streamError ? 24 : 0,\\n            lineHeight: '1.2',\\n            marginBottom: 16,\\n            textAlign: 'center',\\n            color: '#ff6b6b',\\n            opacity: streamError ? 1 : 0,\\n            transition: 'all 250ms ease-in-out'\\n          }\\n        },\\n        streamError ? streamError.name : ''\\n      ),\\n      h('video', {\\n        ref: function ref(node) {\\n          _this3.video = node;\\n        },\\n        style: {\\n          width: '100%',\\n          maxHeight: 'calc(50vh - 16px)',\\n          background: '#212529',\\n          cursor: 'pointer'\\n        },\\n        src: window.URL ? window.URL.createObjectURL(this.props.stream) : this.props.stream,\\n        autoplay: true,\\n        muted: true,\\n        onClick: this.handleClick\\n      }),\\n      h('canvas', {\\n        ref: function ref(node) {\\n          _this3.canvas = node;\\n        },\\n        style: { display: 'none' }\\n      }),\\n      h(\\n        'div',\\n        {\\n          style: {\\n            display: 'flex',\\n            alignItems: 'center',\\n            justifyContent: 'center',\\n            width: '100%',\\n            marginTop: 16,\\n            marginBottom: 16\\n          }\\n        },\\n        h(\\n          'button',\\n          {\\n            style: {\\n              paddingTop: 8,\\n              paddingRight: 16,\\n              paddingBottom: 8,\\n              paddingLeft: 16,\\n              margin: '0 auto',\\n              fontSize: 20,\\n              lineHeight: '1.6',\\n              color: '#adb5bd',\\n              background: '#343a40',\\n              border: 'none',\\n              outline: 'none',\\n              boxShadow: 'none',\\n              borderRadius: 5,\\n              cursor: 'pointer',\\n              opacity: streamError ? 0 : 1,\\n              transition: 'all 250ms ease-in-out'\\n            },\\n            disabled: streamError,\\n            type: 'button',\\n            onClick: this.handleClick\\n          },\\n          'Take Picture'\\n        )\\n      )\\n    );\\n  };\\n\\n  return Camera;\\n}(Component));\\n\\nvar ImageList = connect(function (state) {\\n  return {\\n    images: state.camera.images,\\n    selectedImageId: state.ui.selectedImageId\\n  };\\n})(function ImageList(_ref3, _ref4) {\\n  var images = _ref3.images,\\n      selectedImageId = _ref3.selectedImageId;\\n  var store = _ref4.store;\\n\\n  return h(\\n    'div',\\n    {\\n      style: {\\n        display: 'flex',\\n        flexFlow: 'wrap'\\n      }\\n    },\\n    images.map(function (image, i) {\\n      return h(Image, {\\n        key: image.id,\\n        image: image,\\n        index: i,\\n        selected: image.id === selectedImageId,\\n        onClick: function onClick() {\\n          store.actions.selectImage(image.id === selectedImageId ? null : image.id);\\n        }\\n      });\\n    })\\n  );\\n});\\n\\nfunction Image(_ref5) {\\n  var image = _ref5.image,\\n      index = _ref5.index,\\n      _onClick = _ref5.onClick,\\n      selected = _ref5.selected;\\n\\n  var wrapperStyles = selected ? {\\n    position: 'fixed',\\n    top: 0,\\n    left: 0,\\n    right: 0,\\n    bottom: 0,\\n    width: '100%',\\n    height: '100%',\\n    display: 'flex',\\n    alignItems: 'center',\\n    justifyContent: 'center',\\n    background: '#f8f9fa',\\n    zIndex: 10\\n  } : {\\n    position: 'relative',\\n    flex: '0 1 auto',\\n    width: 'calc(33% - 4px)',\\n    order: index * -1,\\n    paddingTop: 2,\\n    paddingRight: 2,\\n    paddingBottom: 0,\\n    paddingLeft: 2\\n  };\\n\\n  var imgStyles = selected ? { width: '90%', maxHeight: '90%', borderRadius: 8 } : { width: '100%', borderRadius: 4 };\\n\\n  return h(\\n    'a',\\n    {\\n      style: wrapperStyles,\\n      href: image.url,\\n      target: '_blank',\\n      onClick: function onClick(e) {\\n        e.preventDefault();\\n        _onClick();\\n      }\\n    },\\n    h('img', { src: image.url, style: imgStyles })\\n  );\\n}\\n\\nfunction GithubRibbon() {\\n  return h('iframe', {\\n    src: 'https://ghbtns.com/github-btn.html?user=tkh44&repo=smitty&type=star&count=true&size=large',\\n    frameborder: '0',\\n    scrolling: '0',\\n    width: '160px',\\n    height: '30px',\\n    style: { marginLeft: 'auto' }\\n  });\\n}\\n\\nvar App = connect(function (state) {\\n  return state;\\n})(function (props) {\\n  var _ref6;\\n\\n  return h(\\n    'div',\\n    { style: { display: 'flex' } },\\n    h(\\n      'div',\\n      {\\n        style: (_ref6 = {\\n          flex: '1 0 50%',\\n          height: '100vh',\\n          background: '#212529',\\n          overflow: 'auto',\\n          WebkitOverflowScrolling: 'touch'\\n        }, _ref6['background'] = props.camera.streamError ? '#f8f9fa' : '#212529', _ref6.cursor = 'pointer', _ref6.transition = 'all 250ms ease-in-out', _ref6)\\n      },\\n      h(Camera, null)\\n    ),\\n    h(\\n      'div',\\n      {\\n        style: {\\n          flex: '1 0 50%',\\n          height: '100vh',\\n          background: '#f8f9fa',\\n          borderLeft: '1px solid #dee2e6',\\n          overflow: 'auto',\\n          WebkitOverflowScrolling: 'touch'\\n        }\\n      },\\n      h(\\n        'div',\\n        {\\n          style: {\\n            display: 'flex',\\n            alignItems: 'center',\\n            borderBottom: '1px solid #dee2e6',\\n            paddingRight: 8,\\n            paddingLeft: 8\\n          }\\n        },\\n        h(\\n          'h2',\\n          null,\\n          'Smitty Photo Booth Demo'\\n        ),\\n        h(\\n          'a',\\n          {\\n            href: 'https://github.com/tkh44/smitty/tree/master/demo/src',\\n            style: { fontSize: '1rem', color: '#329af0', marginLeft: 8 },\\n            target: '_blank'\\n          },\\n          'source'\\n        ),\\n        h(GithubRibbon, null)\\n      ),\\n      h(ImageList, null)\\n    )\\n  );\\n});\\n\\nvar Root = function Root(props) {\\n  return h(\\n    Provider,\\n    { store: store },\\n    h(App, null)\\n  );\\n};\\n\\nexport default Root;\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/raw-loader!./demo/src/App.js\n// module id = +iyJ\n// module chunks = 0","/*!\n    localForage -- Offline Storage, Improved\n    Version 1.5.0\n    https://localforage.github.io/localForage\n    (c) 2013-2017 Mozilla, Apache License 2.0\n*/\n(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.localforage = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw (f.code=\"MODULE_NOT_FOUND\", f)}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\n(function (global){\n'use strict';\nvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\nvar scheduleDrain;\n\n{\n  if (Mutation) {\n    var called = 0;\n    var observer = new Mutation(nextTick);\n    var element = global.document.createTextNode('');\n    observer.observe(element, {\n      characterData: true\n    });\n    scheduleDrain = function () {\n      element.data = (called = ++called % 2);\n    };\n  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n    var channel = new global.MessageChannel();\n    channel.port1.onmessage = nextTick;\n    scheduleDrain = function () {\n      channel.port2.postMessage(0);\n    };\n  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n    scheduleDrain = function () {\n\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n      var scriptEl = global.document.createElement('script');\n      scriptEl.onreadystatechange = function () {\n        nextTick();\n\n        scriptEl.onreadystatechange = null;\n        scriptEl.parentNode.removeChild(scriptEl);\n        scriptEl = null;\n      };\n      global.document.documentElement.appendChild(scriptEl);\n    };\n  } else {\n    scheduleDrain = function () {\n      setTimeout(nextTick, 0);\n    };\n  }\n}\n\nvar draining;\nvar queue = [];\n//named nextTick for less confusing stack traces\nfunction nextTick() {\n  draining = true;\n  var i, oldQueue;\n  var len = queue.length;\n  while (len) {\n    oldQueue = queue;\n    queue = [];\n    i = -1;\n    while (++i < len) {\n      oldQueue[i]();\n    }\n    len = queue.length;\n  }\n  draining = false;\n}\n\nmodule.exports = immediate;\nfunction immediate(task) {\n  if (queue.push(task) === 1 && !draining) {\n    scheduleDrain();\n  }\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],2:[function(_dereq_,module,exports){\n'use strict';\nvar immediate = _dereq_(1);\n\n/* istanbul ignore next */\nfunction INTERNAL() {}\n\nvar handlers = {};\n\nvar REJECTED = ['REJECTED'];\nvar FULFILLED = ['FULFILLED'];\nvar PENDING = ['PENDING'];\n\nmodule.exports = exports = Promise;\n\nfunction Promise(resolver) {\n  if (typeof resolver !== 'function') {\n    throw new TypeError('resolver must be a function');\n  }\n  this.state = PENDING;\n  this.queue = [];\n  this.outcome = void 0;\n  if (resolver !== INTERNAL) {\n    safelyResolveThenable(this, resolver);\n  }\n}\n\nPromise.prototype[\"catch\"] = function (onRejected) {\n  return this.then(null, onRejected);\n};\nPromise.prototype.then = function (onFulfilled, onRejected) {\n  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||\n    typeof onRejected !== 'function' && this.state === REJECTED) {\n    return this;\n  }\n  var promise = new this.constructor(INTERNAL);\n  if (this.state !== PENDING) {\n    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n    unwrap(promise, resolver, this.outcome);\n  } else {\n    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n  }\n\n  return promise;\n};\nfunction QueueItem(promise, onFulfilled, onRejected) {\n  this.promise = promise;\n  if (typeof onFulfilled === 'function') {\n    this.onFulfilled = onFulfilled;\n    this.callFulfilled = this.otherCallFulfilled;\n  }\n  if (typeof onRejected === 'function') {\n    this.onRejected = onRejected;\n    this.callRejected = this.otherCallRejected;\n  }\n}\nQueueItem.prototype.callFulfilled = function (value) {\n  handlers.resolve(this.promise, value);\n};\nQueueItem.prototype.otherCallFulfilled = function (value) {\n  unwrap(this.promise, this.onFulfilled, value);\n};\nQueueItem.prototype.callRejected = function (value) {\n  handlers.reject(this.promise, value);\n};\nQueueItem.prototype.otherCallRejected = function (value) {\n  unwrap(this.promise, this.onRejected, value);\n};\n\nfunction unwrap(promise, func, value) {\n  immediate(function () {\n    var returnValue;\n    try {\n      returnValue = func(value);\n    } catch (e) {\n      return handlers.reject(promise, e);\n    }\n    if (returnValue === promise) {\n      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n    } else {\n      handlers.resolve(promise, returnValue);\n    }\n  });\n}\n\nhandlers.resolve = function (self, value) {\n  var result = tryCatch(getThen, value);\n  if (result.status === 'error') {\n    return handlers.reject(self, result.value);\n  }\n  var thenable = result.value;\n\n  if (thenable) {\n    safelyResolveThenable(self, thenable);\n  } else {\n    self.state = FULFILLED;\n    self.outcome = value;\n    var i = -1;\n    var len = self.queue.length;\n    while (++i < len) {\n      self.queue[i].callFulfilled(value);\n    }\n  }\n  return self;\n};\nhandlers.reject = function (self, error) {\n  self.state = REJECTED;\n  self.outcome = error;\n  var i = -1;\n  var len = self.queue.length;\n  while (++i < len) {\n    self.queue[i].callRejected(error);\n  }\n  return self;\n};\n\nfunction getThen(obj) {\n  // Make sure we only access the accessor once as required by the spec\n  var then = obj && obj.then;\n  if (obj && typeof obj === 'object' && typeof then === 'function') {\n    return function appyThen() {\n      then.apply(obj, arguments);\n    };\n  }\n}\n\nfunction safelyResolveThenable(self, thenable) {\n  // Either fulfill, reject or reject with error\n  var called = false;\n  function onError(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.reject(self, value);\n  }\n\n  function onSuccess(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.resolve(self, value);\n  }\n\n  function tryToUnwrap() {\n    thenable(onSuccess, onError);\n  }\n\n  var result = tryCatch(tryToUnwrap);\n  if (result.status === 'error') {\n    onError(result.value);\n  }\n}\n\nfunction tryCatch(func, value) {\n  var out = {};\n  try {\n    out.value = func(value);\n    out.status = 'success';\n  } catch (e) {\n    out.status = 'error';\n    out.value = e;\n  }\n  return out;\n}\n\nexports.resolve = resolve;\nfunction resolve(value) {\n  if (value instanceof this) {\n    return value;\n  }\n  return handlers.resolve(new this(INTERNAL), value);\n}\n\nexports.reject = reject;\nfunction reject(reason) {\n  var promise = new this(INTERNAL);\n  return handlers.reject(promise, reason);\n}\n\nexports.all = all;\nfunction all(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var values = new Array(len);\n  var resolved = 0;\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    allResolver(iterable[i], i);\n  }\n  return promise;\n  function allResolver(value, i) {\n    self.resolve(value).then(resolveFromAll, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n    function resolveFromAll(outValue) {\n      values[i] = outValue;\n      if (++resolved === len && !called) {\n        called = true;\n        handlers.resolve(promise, values);\n      }\n    }\n  }\n}\n\nexports.race = race;\nfunction race(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    resolver(iterable[i]);\n  }\n  return promise;\n  function resolver(value) {\n    self.resolve(value).then(function (response) {\n      if (!called) {\n        called = true;\n        handlers.resolve(promise, response);\n      }\n    }, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n  }\n}\n\n},{\"1\":1}],3:[function(_dereq_,module,exports){\n(function (global){\n'use strict';\nif (typeof global.Promise !== 'function') {\n  global.Promise = _dereq_(2);\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"2\":2}],4:[function(_dereq_,module,exports){\n'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction getIDB() {\n    /* global indexedDB,webkitIndexedDB,mozIndexedDB,OIndexedDB,msIndexedDB */\n    try {\n        if (typeof indexedDB !== 'undefined') {\n            return indexedDB;\n        }\n        if (typeof webkitIndexedDB !== 'undefined') {\n            return webkitIndexedDB;\n        }\n        if (typeof mozIndexedDB !== 'undefined') {\n            return mozIndexedDB;\n        }\n        if (typeof OIndexedDB !== 'undefined') {\n            return OIndexedDB;\n        }\n        if (typeof msIndexedDB !== 'undefined') {\n            return msIndexedDB;\n        }\n    } catch (e) {}\n}\n\nvar idb = getIDB();\n\nfunction isIndexedDBValid() {\n    try {\n        // Initialize IndexedDB; fall back to vendor-prefixed versions\n        // if needed.\n        if (!idb) {\n            return false;\n        }\n        // We mimic PouchDB here;\n        //\n        // We test for openDatabase because IE Mobile identifies itself\n        // as Safari. Oh the lulz...\n        var isSafari = typeof openDatabase !== 'undefined' && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);\n\n        var hasFetch = typeof fetch === 'function' && fetch.toString().indexOf('[native code') !== -1;\n\n        // Safari <10.1 does not meet our requirements for IDB support (#5572)\n        // since Safari 10.1 shipped with fetch, we can use that to detect it\n        return (!isSafari || hasFetch) && typeof indexedDB !== 'undefined' &&\n        // some outdated implementations of IDB that appear on Samsung\n        // and HTC Android devices <4.4 are missing IDBKeyRange\n        typeof IDBKeyRange !== 'undefined';\n    } catch (e) {\n        return false;\n    }\n}\n\nfunction isWebSQLValid() {\n    return typeof openDatabase === 'function';\n}\n\nfunction isLocalStorageValid() {\n    try {\n        return typeof localStorage !== 'undefined' && 'setItem' in localStorage && localStorage.setItem;\n    } catch (e) {\n        return false;\n    }\n}\n\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor. (i.e.\n// old QtWebKit versions, at least).\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor. (i.e.\n// old QtWebKit versions, at least).\nfunction createBlob(parts, properties) {\n    /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n    parts = parts || [];\n    properties = properties || {};\n    try {\n        return new Blob(parts, properties);\n    } catch (e) {\n        if (e.name !== 'TypeError') {\n            throw e;\n        }\n        var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : WebKitBlobBuilder;\n        var builder = new Builder();\n        for (var i = 0; i < parts.length; i += 1) {\n            builder.append(parts[i]);\n        }\n        return builder.getBlob(properties.type);\n    }\n}\n\n// This is CommonJS because lie is an external dependency, so Rollup\n// can just ignore it.\nif (typeof Promise === 'undefined') {\n    // In the \"nopromises\" build this will just throw if you don't have\n    // a global promise object, but it would throw anyway later.\n    _dereq_(3);\n}\nvar Promise$1 = Promise;\n\nfunction executeCallback(promise, callback) {\n    if (callback) {\n        promise.then(function (result) {\n            callback(null, result);\n        }, function (error) {\n            callback(error);\n        });\n    }\n}\n\nfunction executeTwoCallbacks(promise, callback, errorCallback) {\n    if (typeof callback === 'function') {\n        promise.then(callback);\n    }\n\n    if (typeof errorCallback === 'function') {\n        promise[\"catch\"](errorCallback);\n    }\n}\n\n// Some code originally from async_storage.js in\n// [Gaia](https://github.com/mozilla-b2g/gaia).\n\nvar DETECT_BLOB_SUPPORT_STORE = 'local-forage-detect-blob-support';\nvar supportsBlobs;\nvar dbContexts;\nvar toString = Object.prototype.toString;\n\n// Transform a binary string to an array buffer, because otherwise\n// weird stuff happens when you try to work with the binary string directly.\n// It is known.\n// From http://stackoverflow.com/questions/14967647/ (continues on next line)\n// encode-decode-image-with-base64-breaks-image (2013-04-21)\nfunction _binStringToArrayBuffer(bin) {\n    var length = bin.length;\n    var buf = new ArrayBuffer(length);\n    var arr = new Uint8Array(buf);\n    for (var i = 0; i < length; i++) {\n        arr[i] = bin.charCodeAt(i);\n    }\n    return buf;\n}\n\n//\n// Blobs are not supported in all versions of IndexedDB, notably\n// Chrome <37 and Android <5. In those versions, storing a blob will throw.\n//\n// Various other blob bugs exist in Chrome v37-42 (inclusive).\n// Detecting them is expensive and confusing to users, and Chrome 37-42\n// is at very low usage worldwide, so we do a hacky userAgent check instead.\n//\n// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\n// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n//\n// Code borrowed from PouchDB. See:\n// https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-adapter-idb/src/blobSupport.js\n//\nfunction _checkBlobSupportWithoutCaching(idb) {\n    return new Promise$1(function (resolve) {\n        var txn = idb.transaction(DETECT_BLOB_SUPPORT_STORE, 'readwrite');\n        var blob = createBlob(['']);\n        txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');\n\n        txn.onabort = function (e) {\n            // If the transaction aborts now its due to not being able to\n            // write to the database, likely due to the disk being full\n            e.preventDefault();\n            e.stopPropagation();\n            resolve(false);\n        };\n\n        txn.oncomplete = function () {\n            var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n            var matchedEdge = navigator.userAgent.match(/Edge\\//);\n            // MS Edge pretends to be Chrome 42:\n            // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\n            resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);\n        };\n    })[\"catch\"](function () {\n        return false; // error, so assume unsupported\n    });\n}\n\nfunction _checkBlobSupport(idb) {\n    if (typeof supportsBlobs === 'boolean') {\n        return Promise$1.resolve(supportsBlobs);\n    }\n    return _checkBlobSupportWithoutCaching(idb).then(function (value) {\n        supportsBlobs = value;\n        return supportsBlobs;\n    });\n}\n\nfunction _deferReadiness(dbInfo) {\n    var dbContext = dbContexts[dbInfo.name];\n\n    // Create a deferred object representing the current database operation.\n    var deferredOperation = {};\n\n    deferredOperation.promise = new Promise$1(function (resolve) {\n        deferredOperation.resolve = resolve;\n    });\n\n    // Enqueue the deferred operation.\n    dbContext.deferredOperations.push(deferredOperation);\n\n    // Chain its promise to the database readiness.\n    if (!dbContext.dbReady) {\n        dbContext.dbReady = deferredOperation.promise;\n    } else {\n        dbContext.dbReady = dbContext.dbReady.then(function () {\n            return deferredOperation.promise;\n        });\n    }\n}\n\nfunction _advanceReadiness(dbInfo) {\n    var dbContext = dbContexts[dbInfo.name];\n\n    // Dequeue a deferred operation.\n    var deferredOperation = dbContext.deferredOperations.pop();\n\n    // Resolve its promise (which is part of the database readiness\n    // chain of promises).\n    if (deferredOperation) {\n        deferredOperation.resolve();\n    }\n}\n\nfunction _getConnection(dbInfo, upgradeNeeded) {\n    return new Promise$1(function (resolve, reject) {\n\n        if (dbInfo.db) {\n            if (upgradeNeeded) {\n                _deferReadiness(dbInfo);\n                dbInfo.db.close();\n            } else {\n                return resolve(dbInfo.db);\n            }\n        }\n\n        var dbArgs = [dbInfo.name];\n\n        if (upgradeNeeded) {\n            dbArgs.push(dbInfo.version);\n        }\n\n        var openreq = idb.open.apply(idb, dbArgs);\n\n        if (upgradeNeeded) {\n            openreq.onupgradeneeded = function (e) {\n                var db = openreq.result;\n                try {\n                    db.createObjectStore(dbInfo.storeName);\n                    if (e.oldVersion <= 1) {\n                        // Added when support for blob shims was added\n                        db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n                    }\n                } catch (ex) {\n                    if (ex.name === 'ConstraintError') {\n                        console.warn('The database \"' + dbInfo.name + '\"' + ' has been upgraded from version ' + e.oldVersion + ' to version ' + e.newVersion + ', but the storage \"' + dbInfo.storeName + '\" already exists.');\n                    } else {\n                        throw ex;\n                    }\n                }\n            };\n        }\n\n        openreq.onerror = function (e) {\n            e.preventDefault();\n            reject(openreq.error);\n        };\n\n        openreq.onsuccess = function () {\n            resolve(openreq.result);\n            _advanceReadiness(dbInfo);\n        };\n    });\n}\n\nfunction _getOriginalConnection(dbInfo) {\n    return _getConnection(dbInfo, false);\n}\n\nfunction _getUpgradedConnection(dbInfo) {\n    return _getConnection(dbInfo, true);\n}\n\nfunction _isUpgradeNeeded(dbInfo, defaultVersion) {\n    if (!dbInfo.db) {\n        return true;\n    }\n\n    var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);\n    var isDowngrade = dbInfo.version < dbInfo.db.version;\n    var isUpgrade = dbInfo.version > dbInfo.db.version;\n\n    if (isDowngrade) {\n        // If the version is not the default one\n        // then warn for impossible downgrade.\n        if (dbInfo.version !== defaultVersion) {\n            console.warn('The database \"' + dbInfo.name + '\"' + ' can\\'t be downgraded from version ' + dbInfo.db.version + ' to version ' + dbInfo.version + '.');\n        }\n        // Align the versions to prevent errors.\n        dbInfo.version = dbInfo.db.version;\n    }\n\n    if (isUpgrade || isNewStore) {\n        // If the store is new then increment the version (if needed).\n        // This will trigger an \"upgradeneeded\" event which is required\n        // for creating a store.\n        if (isNewStore) {\n            var incVersion = dbInfo.db.version + 1;\n            if (incVersion > dbInfo.version) {\n                dbInfo.version = incVersion;\n            }\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n// encode a blob for indexeddb engines that don't support blobs\nfunction _encodeBlob(blob) {\n    return new Promise$1(function (resolve, reject) {\n        var reader = new FileReader();\n        reader.onerror = reject;\n        reader.onloadend = function (e) {\n            var base64 = btoa(e.target.result || '');\n            resolve({\n                __local_forage_encoded_blob: true,\n                data: base64,\n                type: blob.type\n            });\n        };\n        reader.readAsBinaryString(blob);\n    });\n}\n\n// decode an encoded blob\nfunction _decodeBlob(encodedBlob) {\n    var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));\n    return createBlob([arrayBuff], { type: encodedBlob.type });\n}\n\n// is this one of our fancy encoded blobs?\nfunction _isEncodedBlob(value) {\n    return value && value.__local_forage_encoded_blob;\n}\n\n// Specialize the default `ready()` function by making it dependent\n// on the current database operations. Thus, the driver will be actually\n// ready when it's been initialized (default) *and* there are no pending\n// operations on the database (initiated by some other instances).\nfunction _fullyReady(callback) {\n    var self = this;\n\n    var promise = self._initReady().then(function () {\n        var dbContext = dbContexts[self._dbInfo.name];\n\n        if (dbContext && dbContext.dbReady) {\n            return dbContext.dbReady;\n        }\n    });\n\n    executeTwoCallbacks(promise, callback, callback);\n    return promise;\n}\n\n// Open the IndexedDB database (automatically creates one if one didn't\n// previously exist), using any options set in the config.\nfunction _initStorage(options) {\n    var self = this;\n    var dbInfo = {\n        db: null\n    };\n\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = options[i];\n        }\n    }\n\n    // Initialize a singleton container for all running localForages.\n    if (!dbContexts) {\n        dbContexts = {};\n    }\n\n    // Get the current context of the database;\n    var dbContext = dbContexts[dbInfo.name];\n\n    // ...or create a new context.\n    if (!dbContext) {\n        dbContext = {\n            // Running localForages sharing a database.\n            forages: [],\n            // Shared database.\n            db: null,\n            // Database readiness (promise).\n            dbReady: null,\n            // Deferred operations on the database.\n            deferredOperations: []\n        };\n        // Register the new context in the global container.\n        dbContexts[dbInfo.name] = dbContext;\n    }\n\n    // Register itself as a running localForage in the current context.\n    dbContext.forages.push(self);\n\n    // Replace the default `ready()` function with the specialized one.\n    if (!self._initReady) {\n        self._initReady = self.ready;\n        self.ready = _fullyReady;\n    }\n\n    // Create an array of initialization states of the related localForages.\n    var initPromises = [];\n\n    function ignoreErrors() {\n        // Don't handle errors here,\n        // just makes sure related localForages aren't pending.\n        return Promise$1.resolve();\n    }\n\n    for (var j = 0; j < dbContext.forages.length; j++) {\n        var forage = dbContext.forages[j];\n        if (forage !== self) {\n            // Don't wait for itself...\n            initPromises.push(forage._initReady()[\"catch\"](ignoreErrors));\n        }\n    }\n\n    // Take a snapshot of the related localForages.\n    var forages = dbContext.forages.slice(0);\n\n    // Initialize the connection process only when\n    // all the related localForages aren't pending.\n    return Promise$1.all(initPromises).then(function () {\n        dbInfo.db = dbContext.db;\n        // Get the connection or open a new one without upgrade.\n        return _getOriginalConnection(dbInfo);\n    }).then(function (db) {\n        dbInfo.db = db;\n        if (_isUpgradeNeeded(dbInfo, self._defaultConfig.version)) {\n            // Reopen the database for upgrading.\n            return _getUpgradedConnection(dbInfo);\n        }\n        return db;\n    }).then(function (db) {\n        dbInfo.db = dbContext.db = db;\n        self._dbInfo = dbInfo;\n        // Share the final connection amongst related localForages.\n        for (var k = 0; k < forages.length; k++) {\n            var forage = forages[k];\n            if (forage !== self) {\n                // Self is already up-to-date.\n                forage._dbInfo.db = dbInfo.db;\n                forage._dbInfo.version = dbInfo.version;\n            }\n        }\n    });\n}\n\nfunction getItem(key, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);\n            var req = store.get(key);\n\n            req.onsuccess = function () {\n                var value = req.result;\n                if (value === undefined) {\n                    value = null;\n                }\n                if (_isEncodedBlob(value)) {\n                    value = _decodeBlob(value);\n                }\n                resolve(value);\n            };\n\n            req.onerror = function () {\n                reject(req.error);\n            };\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Iterate over all items stored in database.\nfunction iterate(iterator, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);\n\n            var req = store.openCursor();\n            var iterationNumber = 1;\n\n            req.onsuccess = function () {\n                var cursor = req.result;\n\n                if (cursor) {\n                    var value = cursor.value;\n                    if (_isEncodedBlob(value)) {\n                        value = _decodeBlob(value);\n                    }\n                    var result = iterator(value, cursor.key, iterationNumber++);\n\n                    if (result !== void 0) {\n                        resolve(result);\n                    } else {\n                        cursor[\"continue\"]();\n                    }\n                } else {\n                    resolve();\n                }\n            };\n\n            req.onerror = function () {\n                reject(req.error);\n            };\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n\n    return promise;\n}\n\nfunction setItem(key, value, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = new Promise$1(function (resolve, reject) {\n        var dbInfo;\n        self.ready().then(function () {\n            dbInfo = self._dbInfo;\n            if (toString.call(value) === '[object Blob]') {\n                return _checkBlobSupport(dbInfo.db).then(function (blobSupport) {\n                    if (blobSupport) {\n                        return value;\n                    }\n                    return _encodeBlob(value);\n                });\n            }\n            return value;\n        }).then(function (value) {\n            var transaction = dbInfo.db.transaction(dbInfo.storeName, 'readwrite');\n            var store = transaction.objectStore(dbInfo.storeName);\n            var req = store.put(value, key);\n\n            // The reason we don't _save_ null is because IE 10 does\n            // not support saving the `null` type in IndexedDB. How\n            // ironic, given the bug below!\n            // See: https://github.com/mozilla/localForage/issues/161\n            if (value === null) {\n                value = undefined;\n            }\n\n            transaction.oncomplete = function () {\n                // Cast to undefined so the value passed to\n                // callback/promise is the same as what one would get out\n                // of `getItem()` later. This leads to some weirdness\n                // (setItem('foo', undefined) will return `null`), but\n                // it's not my fault localStorage is our baseline and that\n                // it's weird.\n                if (value === undefined) {\n                    value = null;\n                }\n\n                resolve(value);\n            };\n            transaction.onabort = transaction.onerror = function () {\n                var err = req.error ? req.error : req.transaction.error;\n                reject(err);\n            };\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction removeItem(key, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var transaction = dbInfo.db.transaction(dbInfo.storeName, 'readwrite');\n            var store = transaction.objectStore(dbInfo.storeName);\n\n            // We use a Grunt task to make this safe for IE and some\n            // versions of Android (including those used by Cordova).\n            // Normally IE won't like `.delete()` and will insist on\n            // using `['delete']()`, but we have a build step that\n            // fixes this for us now.\n            var req = store[\"delete\"](key);\n            transaction.oncomplete = function () {\n                resolve();\n            };\n\n            transaction.onerror = function () {\n                reject(req.error);\n            };\n\n            // The request will be also be aborted if we've exceeded our storage\n            // space.\n            transaction.onabort = function () {\n                var err = req.error ? req.error : req.transaction.error;\n                reject(err);\n            };\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction clear(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var transaction = dbInfo.db.transaction(dbInfo.storeName, 'readwrite');\n            var store = transaction.objectStore(dbInfo.storeName);\n            var req = store.clear();\n\n            transaction.oncomplete = function () {\n                resolve();\n            };\n\n            transaction.onabort = transaction.onerror = function () {\n                var err = req.error ? req.error : req.transaction.error;\n                reject(err);\n            };\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction length(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);\n            var req = store.count();\n\n            req.onsuccess = function () {\n                resolve(req.result);\n            };\n\n            req.onerror = function () {\n                reject(req.error);\n            };\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction key(n, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        if (n < 0) {\n            resolve(null);\n\n            return;\n        }\n\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);\n\n            var advanced = false;\n            var req = store.openCursor();\n            req.onsuccess = function () {\n                var cursor = req.result;\n                if (!cursor) {\n                    // this means there weren't enough keys\n                    resolve(null);\n\n                    return;\n                }\n\n                if (n === 0) {\n                    // We have the first key, return it if that's what they\n                    // wanted.\n                    resolve(cursor.key);\n                } else {\n                    if (!advanced) {\n                        // Otherwise, ask the cursor to skip ahead n\n                        // records.\n                        advanced = true;\n                        cursor.advance(n);\n                    } else {\n                        // When we get here, we've got the nth key.\n                        resolve(cursor.key);\n                    }\n                }\n            };\n\n            req.onerror = function () {\n                reject(req.error);\n            };\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);\n\n            var req = store.openCursor();\n            var keys = [];\n\n            req.onsuccess = function () {\n                var cursor = req.result;\n\n                if (!cursor) {\n                    resolve(keys);\n                    return;\n                }\n\n                keys.push(cursor.key);\n                cursor[\"continue\"]();\n            };\n\n            req.onerror = function () {\n                reject(req.error);\n            };\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar asyncStorage = {\n    _driver: 'asyncStorage',\n    _initStorage: _initStorage,\n    iterate: iterate,\n    getItem: getItem,\n    setItem: setItem,\n    removeItem: removeItem,\n    clear: clear,\n    length: length,\n    key: key,\n    keys: keys\n};\n\n// Sadly, the best way to save binary data in WebSQL/localStorage is serializing\n// it to Base64, so this is how we store it to prevent very strange errors with less\n// verbose ways of binary <-> string data storage.\nvar BASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\nvar BLOB_TYPE_PREFIX = '~~local_forage_type~';\nvar BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;\n\nvar SERIALIZED_MARKER = '__lfsc__:';\nvar SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;\n\n// OMG the serializations!\nvar TYPE_ARRAYBUFFER = 'arbf';\nvar TYPE_BLOB = 'blob';\nvar TYPE_INT8ARRAY = 'si08';\nvar TYPE_UINT8ARRAY = 'ui08';\nvar TYPE_UINT8CLAMPEDARRAY = 'uic8';\nvar TYPE_INT16ARRAY = 'si16';\nvar TYPE_INT32ARRAY = 'si32';\nvar TYPE_UINT16ARRAY = 'ur16';\nvar TYPE_UINT32ARRAY = 'ui32';\nvar TYPE_FLOAT32ARRAY = 'fl32';\nvar TYPE_FLOAT64ARRAY = 'fl64';\nvar TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;\n\nvar toString$1 = Object.prototype.toString;\n\nfunction stringToBuffer(serializedString) {\n    // Fill the string into a ArrayBuffer.\n    var bufferLength = serializedString.length * 0.75;\n    var len = serializedString.length;\n    var i;\n    var p = 0;\n    var encoded1, encoded2, encoded3, encoded4;\n\n    if (serializedString[serializedString.length - 1] === '=') {\n        bufferLength--;\n        if (serializedString[serializedString.length - 2] === '=') {\n            bufferLength--;\n        }\n    }\n\n    var buffer = new ArrayBuffer(bufferLength);\n    var bytes = new Uint8Array(buffer);\n\n    for (i = 0; i < len; i += 4) {\n        encoded1 = BASE_CHARS.indexOf(serializedString[i]);\n        encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);\n        encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);\n        encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);\n\n        /*jslint bitwise: true */\n        bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n    }\n    return buffer;\n}\n\n// Converts a buffer to a string to store, serialized, in the backend\n// storage library.\nfunction bufferToString(buffer) {\n    // base64-arraybuffer\n    var bytes = new Uint8Array(buffer);\n    var base64String = '';\n    var i;\n\n    for (i = 0; i < bytes.length; i += 3) {\n        /*jslint bitwise: true */\n        base64String += BASE_CHARS[bytes[i] >> 2];\n        base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];\n        base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];\n        base64String += BASE_CHARS[bytes[i + 2] & 63];\n    }\n\n    if (bytes.length % 3 === 2) {\n        base64String = base64String.substring(0, base64String.length - 1) + '=';\n    } else if (bytes.length % 3 === 1) {\n        base64String = base64String.substring(0, base64String.length - 2) + '==';\n    }\n\n    return base64String;\n}\n\n// Serialize a value, afterwards executing a callback (which usually\n// instructs the `setItem()` callback/promise to be executed). This is how\n// we store binary data with localStorage.\nfunction serialize(value, callback) {\n    var valueType = '';\n    if (value) {\n        valueType = toString$1.call(value);\n    }\n\n    // Cannot use `value instanceof ArrayBuffer` or such here, as these\n    // checks fail when running the tests using casper.js...\n    //\n    // TODO: See why those tests fail and use a better solution.\n    if (value && (valueType === '[object ArrayBuffer]' || value.buffer && toString$1.call(value.buffer) === '[object ArrayBuffer]')) {\n        // Convert binary arrays to a string and prefix the string with\n        // a special marker.\n        var buffer;\n        var marker = SERIALIZED_MARKER;\n\n        if (value instanceof ArrayBuffer) {\n            buffer = value;\n            marker += TYPE_ARRAYBUFFER;\n        } else {\n            buffer = value.buffer;\n\n            if (valueType === '[object Int8Array]') {\n                marker += TYPE_INT8ARRAY;\n            } else if (valueType === '[object Uint8Array]') {\n                marker += TYPE_UINT8ARRAY;\n            } else if (valueType === '[object Uint8ClampedArray]') {\n                marker += TYPE_UINT8CLAMPEDARRAY;\n            } else if (valueType === '[object Int16Array]') {\n                marker += TYPE_INT16ARRAY;\n            } else if (valueType === '[object Uint16Array]') {\n                marker += TYPE_UINT16ARRAY;\n            } else if (valueType === '[object Int32Array]') {\n                marker += TYPE_INT32ARRAY;\n            } else if (valueType === '[object Uint32Array]') {\n                marker += TYPE_UINT32ARRAY;\n            } else if (valueType === '[object Float32Array]') {\n                marker += TYPE_FLOAT32ARRAY;\n            } else if (valueType === '[object Float64Array]') {\n                marker += TYPE_FLOAT64ARRAY;\n            } else {\n                callback(new Error('Failed to get type for BinaryArray'));\n            }\n        }\n\n        callback(marker + bufferToString(buffer));\n    } else if (valueType === '[object Blob]') {\n        // Conver the blob to a binaryArray and then to a string.\n        var fileReader = new FileReader();\n\n        fileReader.onload = function () {\n            // Backwards-compatible prefix for the blob type.\n            var str = BLOB_TYPE_PREFIX + value.type + '~' + bufferToString(this.result);\n\n            callback(SERIALIZED_MARKER + TYPE_BLOB + str);\n        };\n\n        fileReader.readAsArrayBuffer(value);\n    } else {\n        try {\n            callback(JSON.stringify(value));\n        } catch (e) {\n            console.error(\"Couldn't convert value into a JSON string: \", value);\n\n            callback(null, e);\n        }\n    }\n}\n\n// Deserialize data we've inserted into a value column/field. We place\n// special markers into our strings to mark them as encoded; this isn't\n// as nice as a meta field, but it's the only sane thing we can do whilst\n// keeping localStorage support intact.\n//\n// Oftentimes this will just deserialize JSON content, but if we have a\n// special marker (SERIALIZED_MARKER, defined above), we will extract\n// some kind of arraybuffer/binary data/typed array out of the string.\nfunction deserialize(value) {\n    // If we haven't marked this string as being specially serialized (i.e.\n    // something other than serialized JSON), we can just return it and be\n    // done with it.\n    if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {\n        return JSON.parse(value);\n    }\n\n    // The following code deals with deserializing some kind of Blob or\n    // TypedArray. First we separate out the type of data we're dealing\n    // with from the data itself.\n    var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);\n    var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);\n\n    var blobType;\n    // Backwards-compatible blob type serialization strategy.\n    // DBs created with older versions of localForage will simply not have the blob type.\n    if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {\n        var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);\n        blobType = matcher[1];\n        serializedString = serializedString.substring(matcher[0].length);\n    }\n    var buffer = stringToBuffer(serializedString);\n\n    // Return the right type based on the code/type set during\n    // serialization.\n    switch (type) {\n        case TYPE_ARRAYBUFFER:\n            return buffer;\n        case TYPE_BLOB:\n            return createBlob([buffer], { type: blobType });\n        case TYPE_INT8ARRAY:\n            return new Int8Array(buffer);\n        case TYPE_UINT8ARRAY:\n            return new Uint8Array(buffer);\n        case TYPE_UINT8CLAMPEDARRAY:\n            return new Uint8ClampedArray(buffer);\n        case TYPE_INT16ARRAY:\n            return new Int16Array(buffer);\n        case TYPE_UINT16ARRAY:\n            return new Uint16Array(buffer);\n        case TYPE_INT32ARRAY:\n            return new Int32Array(buffer);\n        case TYPE_UINT32ARRAY:\n            return new Uint32Array(buffer);\n        case TYPE_FLOAT32ARRAY:\n            return new Float32Array(buffer);\n        case TYPE_FLOAT64ARRAY:\n            return new Float64Array(buffer);\n        default:\n            throw new Error('Unkown type: ' + type);\n    }\n}\n\nvar localforageSerializer = {\n    serialize: serialize,\n    deserialize: deserialize,\n    stringToBuffer: stringToBuffer,\n    bufferToString: bufferToString\n};\n\n/*\n * Includes code from:\n *\n * base64-arraybuffer\n * https://github.com/niklasvh/base64-arraybuffer\n *\n * Copyright (c) 2012 Niklas von Hertzen\n * Licensed under the MIT license.\n */\n// Open the WebSQL database (automatically creates one if one didn't\n// previously exist), using any options set in the config.\nfunction _initStorage$1(options) {\n    var self = this;\n    var dbInfo = {\n        db: null\n    };\n\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = typeof options[i] !== 'string' ? options[i].toString() : options[i];\n        }\n    }\n\n    var dbInfoPromise = new Promise$1(function (resolve, reject) {\n        // Open the database; the openDatabase API will automatically\n        // create it for us if it doesn't exist.\n        try {\n            dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);\n        } catch (e) {\n            return reject(e);\n        }\n\n        // Create our key/value table if it doesn't exist.\n        dbInfo.db.transaction(function (t) {\n            t.executeSql('CREATE TABLE IF NOT EXISTS ' + dbInfo.storeName + ' (id INTEGER PRIMARY KEY, key unique, value)', [], function () {\n                self._dbInfo = dbInfo;\n                resolve();\n            }, function (t, error) {\n                reject(error);\n            });\n        });\n    });\n\n    dbInfo.serializer = localforageSerializer;\n    return dbInfoPromise;\n}\n\nfunction getItem$1(key, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('SELECT * FROM ' + dbInfo.storeName + ' WHERE key = ? LIMIT 1', [key], function (t, results) {\n                    var result = results.rows.length ? results.rows.item(0).value : null;\n\n                    // Check to see if this is serialized content we need to\n                    // unpack.\n                    if (result) {\n                        result = dbInfo.serializer.deserialize(result);\n                    }\n\n                    resolve(result);\n                }, function (t, error) {\n\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction iterate$1(iterator, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('SELECT * FROM ' + dbInfo.storeName, [], function (t, results) {\n                    var rows = results.rows;\n                    var length = rows.length;\n\n                    for (var i = 0; i < length; i++) {\n                        var item = rows.item(i);\n                        var result = item.value;\n\n                        // Check to see if this is serialized content\n                        // we need to unpack.\n                        if (result) {\n                            result = dbInfo.serializer.deserialize(result);\n                        }\n\n                        result = iterator(result, item.key, i + 1);\n\n                        // void(0) prevents problems with redefinition\n                        // of `undefined`.\n                        if (result !== void 0) {\n                            resolve(result);\n                            return;\n                        }\n                    }\n\n                    resolve();\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction _setItem(key, value, callback, retriesLeft) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            // The localStorage API doesn't return undefined values in an\n            // \"expected\" way, so undefined is always cast to null in all\n            // drivers. See: https://github.com/mozilla/localForage/pull/42\n            if (value === undefined) {\n                value = null;\n            }\n\n            // Save the original value to pass to the callback.\n            var originalValue = value;\n\n            var dbInfo = self._dbInfo;\n            dbInfo.serializer.serialize(value, function (value, error) {\n                if (error) {\n                    reject(error);\n                } else {\n                    dbInfo.db.transaction(function (t) {\n                        t.executeSql('INSERT OR REPLACE INTO ' + dbInfo.storeName + ' (key, value) VALUES (?, ?)', [key, value], function () {\n                            resolve(originalValue);\n                        }, function (t, error) {\n                            reject(error);\n                        });\n                    }, function (sqlError) {\n                        // The transaction failed; check\n                        // to see if it's a quota error.\n                        if (sqlError.code === sqlError.QUOTA_ERR) {\n                            // We reject the callback outright for now, but\n                            // it's worth trying to re-run the transaction.\n                            // Even if the user accepts the prompt to use\n                            // more storage on Safari, this error will\n                            // be called.\n                            //\n                            // Try to re-run the transaction.\n                            if (retriesLeft > 0) {\n                                resolve(_setItem.apply(self, [key, originalValue, callback, retriesLeft - 1]));\n                                return;\n                            }\n                            reject(sqlError);\n                        }\n                    });\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction setItem$1(key, value, callback) {\n    return _setItem.apply(this, [key, value, callback, 1]);\n}\n\nfunction removeItem$1(key, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('DELETE FROM ' + dbInfo.storeName + ' WHERE key = ?', [key], function () {\n                    resolve();\n                }, function (t, error) {\n\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Deletes every item in the table.\n// TODO: Find out if this resets the AUTO_INCREMENT number.\nfunction clear$1(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('DELETE FROM ' + dbInfo.storeName, [], function () {\n                    resolve();\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Does a simple `COUNT(key)` to get the number of items stored in\n// localForage.\nfunction length$1(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                // Ahhh, SQL makes this one soooooo easy.\n                t.executeSql('SELECT COUNT(key) as c FROM ' + dbInfo.storeName, [], function (t, results) {\n                    var result = results.rows.item(0).c;\n\n                    resolve(result);\n                }, function (t, error) {\n\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Return the key located at key index X; essentially gets the key from a\n// `WHERE id = ?`. This is the most efficient way I can think to implement\n// this rarely-used (in my experience) part of the API, but it can seem\n// inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so\n// the ID of each key will change every time it's updated. Perhaps a stored\n// procedure for the `setItem()` SQL would solve this problem?\n// TODO: Don't change ID on `setItem()`.\nfunction key$1(n, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('SELECT key FROM ' + dbInfo.storeName + ' WHERE id = ? LIMIT 1', [n + 1], function (t, results) {\n                    var result = results.rows.length ? results.rows.item(0).key : null;\n                    resolve(result);\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys$1(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                t.executeSql('SELECT key FROM ' + dbInfo.storeName, [], function (t, results) {\n                    var keys = [];\n\n                    for (var i = 0; i < results.rows.length; i++) {\n                        keys.push(results.rows.item(i).key);\n                    }\n\n                    resolve(keys);\n                }, function (t, error) {\n\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar webSQLStorage = {\n    _driver: 'webSQLStorage',\n    _initStorage: _initStorage$1,\n    iterate: iterate$1,\n    getItem: getItem$1,\n    setItem: setItem$1,\n    removeItem: removeItem$1,\n    clear: clear$1,\n    length: length$1,\n    key: key$1,\n    keys: keys$1\n};\n\n// Config the localStorage backend, using options set in the config.\nfunction _initStorage$2(options) {\n    var self = this;\n    var dbInfo = {};\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = options[i];\n        }\n    }\n\n    dbInfo.keyPrefix = dbInfo.name + '/';\n\n    if (dbInfo.storeName !== self._defaultConfig.storeName) {\n        dbInfo.keyPrefix += dbInfo.storeName + '/';\n    }\n\n    self._dbInfo = dbInfo;\n    dbInfo.serializer = localforageSerializer;\n\n    return Promise$1.resolve();\n}\n\n// Remove all keys from the datastore, effectively destroying all data in\n// the app's key/value store!\nfunction clear$2(callback) {\n    var self = this;\n    var promise = self.ready().then(function () {\n        var keyPrefix = self._dbInfo.keyPrefix;\n\n        for (var i = localStorage.length - 1; i >= 0; i--) {\n            var key = localStorage.key(i);\n\n            if (key.indexOf(keyPrefix) === 0) {\n                localStorage.removeItem(key);\n            }\n        }\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Retrieve an item from the store. Unlike the original async_storage\n// library in Gaia, we don't modify return values at all. If a key's value\n// is `undefined`, we pass that value to the callback function.\nfunction getItem$2(key, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var result = localStorage.getItem(dbInfo.keyPrefix + key);\n\n        // If a result was found, parse it from the serialized\n        // string into a JS object. If result isn't truthy, the key\n        // is likely undefined and we'll pass it straight to the\n        // callback.\n        if (result) {\n            result = dbInfo.serializer.deserialize(result);\n        }\n\n        return result;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Iterate over all items in the store.\nfunction iterate$2(iterator, callback) {\n    var self = this;\n\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var keyPrefix = dbInfo.keyPrefix;\n        var keyPrefixLength = keyPrefix.length;\n        var length = localStorage.length;\n\n        // We use a dedicated iterator instead of the `i` variable below\n        // so other keys we fetch in localStorage aren't counted in\n        // the `iterationNumber` argument passed to the `iterate()`\n        // callback.\n        //\n        // See: github.com/mozilla/localForage/pull/435#discussion_r38061530\n        var iterationNumber = 1;\n\n        for (var i = 0; i < length; i++) {\n            var key = localStorage.key(i);\n            if (key.indexOf(keyPrefix) !== 0) {\n                continue;\n            }\n            var value = localStorage.getItem(key);\n\n            // If a result was found, parse it from the serialized\n            // string into a JS object. If result isn't truthy, the\n            // key is likely undefined and we'll pass it straight\n            // to the iterator.\n            if (value) {\n                value = dbInfo.serializer.deserialize(value);\n            }\n\n            value = iterator(value, key.substring(keyPrefixLength), iterationNumber++);\n\n            if (value !== void 0) {\n                return value;\n            }\n        }\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Same as localStorage's key() method, except takes a callback.\nfunction key$2(n, callback) {\n    var self = this;\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var result;\n        try {\n            result = localStorage.key(n);\n        } catch (error) {\n            result = null;\n        }\n\n        // Remove the prefix from the key, if a key is found.\n        if (result) {\n            result = result.substring(dbInfo.keyPrefix.length);\n        }\n\n        return result;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys$2(callback) {\n    var self = this;\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var length = localStorage.length;\n        var keys = [];\n\n        for (var i = 0; i < length; i++) {\n            if (localStorage.key(i).indexOf(dbInfo.keyPrefix) === 0) {\n                keys.push(localStorage.key(i).substring(dbInfo.keyPrefix.length));\n            }\n        }\n\n        return keys;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Supply the number of keys in the datastore to the callback function.\nfunction length$2(callback) {\n    var self = this;\n    var promise = self.keys().then(function (keys) {\n        return keys.length;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Remove an item from the store, nice and simple.\nfunction removeItem$2(key, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        localStorage.removeItem(dbInfo.keyPrefix + key);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Set a key's value and run an optional callback once the value is set.\n// Unlike Gaia's implementation, the callback function is passed the value,\n// in case you want to operate on that value only after you're sure it\n// saved, or something like that.\nfunction setItem$2(key, value, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = self.ready().then(function () {\n        // Convert undefined values to null.\n        // https://github.com/mozilla/localForage/pull/42\n        if (value === undefined) {\n            value = null;\n        }\n\n        // Save the original value to pass to the callback.\n        var originalValue = value;\n\n        return new Promise$1(function (resolve, reject) {\n            var dbInfo = self._dbInfo;\n            dbInfo.serializer.serialize(value, function (value, error) {\n                if (error) {\n                    reject(error);\n                } else {\n                    try {\n                        localStorage.setItem(dbInfo.keyPrefix + key, value);\n                        resolve(originalValue);\n                    } catch (e) {\n                        // localStorage capacity exceeded.\n                        // TODO: Make this a specific error/event.\n                        if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {\n                            reject(e);\n                        }\n                        reject(e);\n                    }\n                }\n            });\n        });\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar localStorageWrapper = {\n    _driver: 'localStorageWrapper',\n    _initStorage: _initStorage$2,\n    // Default API, from Gaia/localStorage.\n    iterate: iterate$2,\n    getItem: getItem$2,\n    setItem: setItem$2,\n    removeItem: removeItem$2,\n    clear: clear$2,\n    length: length$2,\n    key: key$2,\n    keys: keys$2\n};\n\n// Custom drivers are stored here when `defineDriver()` is called.\n// They are shared across all instances of localForage.\nvar CustomDrivers = {};\n\nvar DriverType = {\n    INDEXEDDB: 'asyncStorage',\n    LOCALSTORAGE: 'localStorageWrapper',\n    WEBSQL: 'webSQLStorage'\n};\n\nvar DefaultDriverOrder = [DriverType.INDEXEDDB, DriverType.WEBSQL, DriverType.LOCALSTORAGE];\n\nvar LibraryMethods = ['clear', 'getItem', 'iterate', 'key', 'keys', 'length', 'removeItem', 'setItem'];\n\nvar DefaultConfig = {\n    description: '',\n    driver: DefaultDriverOrder.slice(),\n    name: 'localforage',\n    // Default DB size is _JUST UNDER_ 5MB, as it's the highest size\n    // we can use without a prompt.\n    size: 4980736,\n    storeName: 'keyvaluepairs',\n    version: 1.0\n};\n\nvar driverSupport = {};\n// Check to see if IndexedDB is available and if it is the latest\n// implementation; it's our preferred backend library. We use \"_spec_test\"\n// as the name of the database because it's not the one we'll operate on,\n// but it's useful to make sure its using the right spec.\n// See: https://github.com/mozilla/localForage/issues/128\ndriverSupport[DriverType.INDEXEDDB] = isIndexedDBValid();\n\ndriverSupport[DriverType.WEBSQL] = isWebSQLValid();\n\ndriverSupport[DriverType.LOCALSTORAGE] = isLocalStorageValid();\n\nvar isArray = Array.isArray || function (arg) {\n    return Object.prototype.toString.call(arg) === '[object Array]';\n};\n\nfunction callWhenReady(localForageInstance, libraryMethod) {\n    localForageInstance[libraryMethod] = function () {\n        var _args = arguments;\n        return localForageInstance.ready().then(function () {\n            return localForageInstance[libraryMethod].apply(localForageInstance, _args);\n        });\n    };\n}\n\nfunction extend() {\n    for (var i = 1; i < arguments.length; i++) {\n        var arg = arguments[i];\n\n        if (arg) {\n            for (var key in arg) {\n                if (arg.hasOwnProperty(key)) {\n                    if (isArray(arg[key])) {\n                        arguments[0][key] = arg[key].slice();\n                    } else {\n                        arguments[0][key] = arg[key];\n                    }\n                }\n            }\n        }\n    }\n\n    return arguments[0];\n}\n\nfunction isLibraryDriver(driverName) {\n    for (var driver in DriverType) {\n        if (DriverType.hasOwnProperty(driver) && DriverType[driver] === driverName) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nvar LocalForage = function () {\n    function LocalForage(options) {\n        _classCallCheck(this, LocalForage);\n\n        this.INDEXEDDB = DriverType.INDEXEDDB;\n        this.LOCALSTORAGE = DriverType.LOCALSTORAGE;\n        this.WEBSQL = DriverType.WEBSQL;\n\n        this._defaultConfig = extend({}, DefaultConfig);\n        this._config = extend({}, this._defaultConfig, options);\n        this._driverSet = null;\n        this._initDriver = null;\n        this._ready = false;\n        this._dbInfo = null;\n\n        this._wrapLibraryMethodsWithReady();\n        this.setDriver(this._config.driver)[\"catch\"](function () {});\n    }\n\n    // Set any config values for localForage; can be called anytime before\n    // the first API call (e.g. `getItem`, `setItem`).\n    // We loop through options so we don't overwrite existing config\n    // values.\n\n\n    LocalForage.prototype.config = function config(options) {\n        // If the options argument is an object, we use it to set values.\n        // Otherwise, we return either a specified config value or all\n        // config values.\n        if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {\n            // If localforage is ready and fully initialized, we can't set\n            // any new configuration values. Instead, we return an error.\n            if (this._ready) {\n                return new Error(\"Can't call config() after localforage \" + 'has been used.');\n            }\n\n            for (var i in options) {\n                if (i === 'storeName') {\n                    options[i] = options[i].replace(/\\W/g, '_');\n                }\n\n                if (i === 'version' && typeof options[i] !== 'number') {\n                    return new Error('Database version must be a number.');\n                }\n\n                this._config[i] = options[i];\n            }\n\n            // after all config options are set and\n            // the driver option is used, try setting it\n            if ('driver' in options && options.driver) {\n                return this.setDriver(this._config.driver);\n            }\n\n            return true;\n        } else if (typeof options === 'string') {\n            return this._config[options];\n        } else {\n            return this._config;\n        }\n    };\n\n    // Used to define a custom driver, shared across all instances of\n    // localForage.\n\n\n    LocalForage.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {\n        var promise = new Promise$1(function (resolve, reject) {\n            try {\n                var driverName = driverObject._driver;\n                var complianceError = new Error('Custom driver not compliant; see ' + 'https://mozilla.github.io/localForage/#definedriver');\n                var namingError = new Error('Custom driver name already in use: ' + driverObject._driver);\n\n                // A driver name should be defined and not overlap with the\n                // library-defined, default drivers.\n                if (!driverObject._driver) {\n                    reject(complianceError);\n                    return;\n                }\n                if (isLibraryDriver(driverObject._driver)) {\n                    reject(namingError);\n                    return;\n                }\n\n                var customDriverMethods = LibraryMethods.concat('_initStorage');\n                for (var i = 0; i < customDriverMethods.length; i++) {\n                    var customDriverMethod = customDriverMethods[i];\n                    if (!customDriverMethod || !driverObject[customDriverMethod] || typeof driverObject[customDriverMethod] !== 'function') {\n                        reject(complianceError);\n                        return;\n                    }\n                }\n\n                var supportPromise = Promise$1.resolve(true);\n                if ('_support' in driverObject) {\n                    if (driverObject._support && typeof driverObject._support === 'function') {\n                        supportPromise = driverObject._support();\n                    } else {\n                        supportPromise = Promise$1.resolve(!!driverObject._support);\n                    }\n                }\n\n                supportPromise.then(function (supportResult) {\n                    driverSupport[driverName] = supportResult;\n                    CustomDrivers[driverName] = driverObject;\n                    resolve();\n                }, reject);\n            } catch (e) {\n                reject(e);\n            }\n        });\n\n        executeTwoCallbacks(promise, callback, errorCallback);\n        return promise;\n    };\n\n    LocalForage.prototype.driver = function driver() {\n        return this._driver || null;\n    };\n\n    LocalForage.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {\n        var self = this;\n        var getDriverPromise = Promise$1.resolve().then(function () {\n            if (isLibraryDriver(driverName)) {\n                switch (driverName) {\n                    case self.INDEXEDDB:\n                        return asyncStorage;\n                    case self.LOCALSTORAGE:\n                        return localStorageWrapper;\n                    case self.WEBSQL:\n                        return webSQLStorage;\n                }\n            } else if (CustomDrivers[driverName]) {\n                return CustomDrivers[driverName];\n            } else {\n                throw new Error('Driver not found.');\n            }\n        });\n        executeTwoCallbacks(getDriverPromise, callback, errorCallback);\n        return getDriverPromise;\n    };\n\n    LocalForage.prototype.getSerializer = function getSerializer(callback) {\n        var serializerPromise = Promise$1.resolve(localforageSerializer);\n        executeTwoCallbacks(serializerPromise, callback);\n        return serializerPromise;\n    };\n\n    LocalForage.prototype.ready = function ready(callback) {\n        var self = this;\n\n        var promise = self._driverSet.then(function () {\n            if (self._ready === null) {\n                self._ready = self._initDriver();\n            }\n\n            return self._ready;\n        });\n\n        executeTwoCallbacks(promise, callback, callback);\n        return promise;\n    };\n\n    LocalForage.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {\n        var self = this;\n\n        if (!isArray(drivers)) {\n            drivers = [drivers];\n        }\n\n        var supportedDrivers = this._getSupportedDrivers(drivers);\n\n        function setDriverToConfig() {\n            self._config.driver = self.driver();\n        }\n\n        function extendSelfWithDriver(driver) {\n            self._extend(driver);\n            setDriverToConfig();\n\n            self._ready = self._initStorage(self._config);\n            return self._ready;\n        }\n\n        function initDriver(supportedDrivers) {\n            return function () {\n                var currentDriverIndex = 0;\n\n                function driverPromiseLoop() {\n                    while (currentDriverIndex < supportedDrivers.length) {\n                        var driverName = supportedDrivers[currentDriverIndex];\n                        currentDriverIndex++;\n\n                        self._dbInfo = null;\n                        self._ready = null;\n\n                        return self.getDriver(driverName).then(extendSelfWithDriver)[\"catch\"](driverPromiseLoop);\n                    }\n\n                    setDriverToConfig();\n                    var error = new Error('No available storage method found.');\n                    self._driverSet = Promise$1.reject(error);\n                    return self._driverSet;\n                }\n\n                return driverPromiseLoop();\n            };\n        }\n\n        // There might be a driver initialization in progress\n        // so wait for it to finish in order to avoid a possible\n        // race condition to set _dbInfo\n        var oldDriverSetDone = this._driverSet !== null ? this._driverSet[\"catch\"](function () {\n            return Promise$1.resolve();\n        }) : Promise$1.resolve();\n\n        this._driverSet = oldDriverSetDone.then(function () {\n            var driverName = supportedDrivers[0];\n            self._dbInfo = null;\n            self._ready = null;\n\n            return self.getDriver(driverName).then(function (driver) {\n                self._driver = driver._driver;\n                setDriverToConfig();\n                self._wrapLibraryMethodsWithReady();\n                self._initDriver = initDriver(supportedDrivers);\n            });\n        })[\"catch\"](function () {\n            setDriverToConfig();\n            var error = new Error('No available storage method found.');\n            self._driverSet = Promise$1.reject(error);\n            return self._driverSet;\n        });\n\n        executeTwoCallbacks(this._driverSet, callback, errorCallback);\n        return this._driverSet;\n    };\n\n    LocalForage.prototype.supports = function supports(driverName) {\n        return !!driverSupport[driverName];\n    };\n\n    LocalForage.prototype._extend = function _extend(libraryMethodsAndProperties) {\n        extend(this, libraryMethodsAndProperties);\n    };\n\n    LocalForage.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {\n        var supportedDrivers = [];\n        for (var i = 0, len = drivers.length; i < len; i++) {\n            var driverName = drivers[i];\n            if (this.supports(driverName)) {\n                supportedDrivers.push(driverName);\n            }\n        }\n        return supportedDrivers;\n    };\n\n    LocalForage.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {\n        // Add a stub for each driver API method that delays the call to the\n        // corresponding driver method until localForage is ready. These stubs\n        // will be replaced by the driver methods as soon as the driver is\n        // loaded, so there is no performance impact.\n        for (var i = 0; i < LibraryMethods.length; i++) {\n            callWhenReady(this, LibraryMethods[i]);\n        }\n    };\n\n    LocalForage.prototype.createInstance = function createInstance(options) {\n        return new LocalForage(options);\n    };\n\n    return LocalForage;\n}();\n\n// The actual localForage object that we expose as a module or via a\n// global. It's extended by pulling in one of our other libraries.\n\n\nvar localforage_js = new LocalForage();\n\nmodule.exports = localforage_js;\n\n},{\"3\":3}]},{},[4])(4)\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/localforage/dist/localforage.js\n// module id = 22C0\n// module chunks = 0","function t(t){function o(e,o){if(\"function\"==typeof t)return t(o.store.state,e)}return function(t){return function(n){function r(t,e){var r=this;n.call(this,t,e),this.state=o(t,e),this.handleStoreUpdate=function(){r.updateAnimId=setTimeout(function(){r.setState(o(r.props,r.context))})},e.store.on('*',this.handleStoreUpdate)}return n&&(r.__proto__=n),r.prototype=Object.create(n&&n.prototype),r.prototype.constructor=r,r.prototype.componentWillUnmount=function(){window.clearTimeout(this.updateAnimId),this.context.store.off('*',this.handleStoreUpdate)},r.prototype.render=function(o, n){return e.h(t,Object.assign({},Object.assign({},o),n,{emit:this.context.store.emit}))},r}(e.Component)}}Object.defineProperty(exports,\"__esModule\",{value:!0});var e=require(\"preact\"),o=function(t){function e(){t.apply(this,arguments)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getChildContext=function(){return{store:this.props.store}},e.prototype.render=function(t){return t.children[0]},e}(e.Component);exports.Provider=o,exports.connect=t;\n//# sourceMappingURL=preact-smitty.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/preact-smitty/dist/preact-smitty.js\n// module id = 97Jz\n// module chunks = 0","!function(global, factory) {\n    'object' == typeof exports && 'undefined' != typeof module ? factory(exports) : 'function' == typeof define && define.amd ? define([ 'exports' ], factory) : factory(global.preact = global.preact || {});\n}(this, function(exports) {\n    function VNode(nodeName, attributes, children) {\n        this.nodeName = nodeName;\n        this.attributes = attributes;\n        this.children = children;\n        this.key = attributes && attributes.key;\n    }\n    function h(nodeName, attributes) {\n        var children, lastSimple, child, simple, i;\n        for (i = arguments.length; i-- > 2; ) stack.push(arguments[i]);\n        if (attributes && attributes.children) {\n            if (!stack.length) stack.push(attributes.children);\n            delete attributes.children;\n        }\n        while (stack.length) if ((child = stack.pop()) instanceof Array) for (i = child.length; i--; ) stack.push(child[i]); else if (null != child && child !== !0 && child !== !1) {\n            if ('number' == typeof child) child = String(child);\n            simple = 'string' == typeof child;\n            if (simple && lastSimple) children[children.length - 1] += child; else {\n                (children || (children = [])).push(child);\n                lastSimple = simple;\n            }\n        }\n        var p = new VNode(nodeName, attributes || void 0, children || EMPTY_CHILDREN);\n        if (options.vnode) options.vnode(p);\n        return p;\n    }\n    function extend(obj, props) {\n        if (props) for (var i in props) obj[i] = props[i];\n        return obj;\n    }\n    function clone(obj) {\n        return extend({}, obj);\n    }\n    function delve(obj, key) {\n        for (var p = key.split('.'), i = 0; i < p.length && obj; i++) obj = obj[p[i]];\n        return obj;\n    }\n    function isFunction(obj) {\n        return 'function' == typeof obj;\n    }\n    function isString(obj) {\n        return 'string' == typeof obj;\n    }\n    function hashToClassName(c) {\n        var str = '';\n        for (var prop in c) if (c[prop]) {\n            if (str) str += ' ';\n            str += prop;\n        }\n        return str;\n    }\n    function cloneElement(vnode, props) {\n        return h(vnode.nodeName, extend(clone(vnode.attributes), props), arguments.length > 2 ? [].slice.call(arguments, 2) : vnode.children);\n    }\n    function createLinkedState(component, key, eventPath) {\n        var path = key.split('.');\n        return function(e) {\n            var t = e && e.target || this, state = {}, obj = state, v = isString(eventPath) ? delve(e, eventPath) : t.nodeName ? t.type.match(/^che|rad/) ? t.checked : t.value : e, i = 0;\n            for (;i < path.length - 1; i++) obj = obj[path[i]] || (obj[path[i]] = !i && component.state[path[i]] || {});\n            obj[path[i]] = v;\n            component.setState(state);\n        };\n    }\n    function enqueueRender(component) {\n        if (!component._dirty && (component._dirty = !0) && 1 == items.push(component)) (options.debounceRendering || defer)(rerender);\n    }\n    function rerender() {\n        var p, list = items;\n        items = [];\n        while (p = list.pop()) if (p._dirty) renderComponent(p);\n    }\n    function isFunctionalComponent(vnode) {\n        var nodeName = vnode && vnode.nodeName;\n        return nodeName && isFunction(nodeName) && !(nodeName.prototype && nodeName.prototype.render);\n    }\n    function buildFunctionalComponent(vnode, context) {\n        return vnode.nodeName(getNodeProps(vnode), context || EMPTY);\n    }\n    function isSameNodeType(node, vnode) {\n        if (isString(vnode)) return node instanceof Text;\n        if (isString(vnode.nodeName)) return !node._componentConstructor && isNamedNode(node, vnode.nodeName);\n        if (isFunction(vnode.nodeName)) return (node._componentConstructor ? node._componentConstructor === vnode.nodeName : !0) || isFunctionalComponent(vnode); else ;\n    }\n    function isNamedNode(node, nodeName) {\n        return node.normalizedNodeName === nodeName || toLowerCase(node.nodeName) === toLowerCase(nodeName);\n    }\n    function getNodeProps(vnode) {\n        var props = clone(vnode.attributes);\n        props.children = vnode.children;\n        var defaultProps = vnode.nodeName.defaultProps;\n        if (defaultProps) for (var i in defaultProps) if (void 0 === props[i]) props[i] = defaultProps[i];\n        return props;\n    }\n    function removeNode(node) {\n        var p = node.parentNode;\n        if (p) p.removeChild(node);\n    }\n    function setAccessor(node, name, old, value, isSvg) {\n        if ('className' === name) name = 'class';\n        if ('class' === name && value && 'object' == typeof value) value = hashToClassName(value);\n        if ('key' === name) ; else if ('class' === name && !isSvg) node.className = value || ''; else if ('style' === name) {\n            if (!value || isString(value) || isString(old)) node.style.cssText = value || '';\n            if (value && 'object' == typeof value) {\n                if (!isString(old)) for (var i in old) if (!(i in value)) node.style[i] = '';\n                for (var i in value) node.style[i] = 'number' == typeof value[i] && !NON_DIMENSION_PROPS[i] ? value[i] + 'px' : value[i];\n            }\n        } else if ('dangerouslySetInnerHTML' === name) {\n            if (value) node.innerHTML = value.__html || '';\n        } else if ('o' == name[0] && 'n' == name[1]) {\n            var l = node._listeners || (node._listeners = {});\n            name = toLowerCase(name.substring(2));\n            if (value) {\n                if (!l[name]) node.addEventListener(name, eventProxy, !!NON_BUBBLING_EVENTS[name]);\n            } else if (l[name]) node.removeEventListener(name, eventProxy, !!NON_BUBBLING_EVENTS[name]);\n            l[name] = value;\n        } else if ('list' !== name && 'type' !== name && !isSvg && name in node) {\n            setProperty(node, name, null == value ? '' : value);\n            if (null == value || value === !1) node.removeAttribute(name);\n        } else {\n            var ns = isSvg && name.match(/^xlink\\:?(.+)/);\n            if (null == value || value === !1) if (ns) node.removeAttributeNS('http://www.w3.org/1999/xlink', toLowerCase(ns[1])); else node.removeAttribute(name); else if ('object' != typeof value && !isFunction(value)) if (ns) node.setAttributeNS('http://www.w3.org/1999/xlink', toLowerCase(ns[1]), value); else node.setAttribute(name, value);\n        }\n    }\n    function setProperty(node, name, value) {\n        try {\n            node[name] = value;\n        } catch (e) {}\n    }\n    function eventProxy(e) {\n        return this._listeners[e.type](options.event && options.event(e) || e);\n    }\n    function collectNode(node) {\n        removeNode(node);\n        if (node instanceof Element) {\n            node._component = node._componentConstructor = null;\n            var _name = node.normalizedNodeName || toLowerCase(node.nodeName);\n            (nodes[_name] || (nodes[_name] = [])).push(node);\n        }\n    }\n    function createNode(nodeName, isSvg) {\n        var name = toLowerCase(nodeName), node = nodes[name] && nodes[name].pop() || (isSvg ? document.createElementNS('http://www.w3.org/2000/svg', nodeName) : document.createElement(nodeName));\n        node.normalizedNodeName = name;\n        return node;\n    }\n    function flushMounts() {\n        var c;\n        while (c = mounts.pop()) {\n            if (options.afterMount) options.afterMount(c);\n            if (c.componentDidMount) c.componentDidMount();\n        }\n    }\n    function diff(dom, vnode, context, mountAll, parent, componentRoot) {\n        if (!diffLevel++) {\n            isSvgMode = parent && 'undefined' != typeof parent.ownerSVGElement;\n            hydrating = dom && !(ATTR_KEY in dom);\n        }\n        var ret = idiff(dom, vnode, context, mountAll);\n        if (parent && ret.parentNode !== parent) parent.appendChild(ret);\n        if (!--diffLevel) {\n            hydrating = !1;\n            if (!componentRoot) flushMounts();\n        }\n        return ret;\n    }\n    function idiff(dom, vnode, context, mountAll) {\n        var ref = vnode && vnode.attributes && vnode.attributes.ref;\n        while (isFunctionalComponent(vnode)) vnode = buildFunctionalComponent(vnode, context);\n        if (null == vnode) vnode = '';\n        if (isString(vnode)) {\n            if (dom && dom instanceof Text && dom.parentNode) {\n                if (dom.nodeValue != vnode) dom.nodeValue = vnode;\n            } else {\n                if (dom) recollectNodeTree(dom);\n                dom = document.createTextNode(vnode);\n            }\n            return dom;\n        }\n        if (isFunction(vnode.nodeName)) return buildComponentFromVNode(dom, vnode, context, mountAll);\n        var out = dom, nodeName = String(vnode.nodeName), prevSvgMode = isSvgMode, vchildren = vnode.children;\n        isSvgMode = 'svg' === nodeName ? !0 : 'foreignObject' === nodeName ? !1 : isSvgMode;\n        if (!dom) out = createNode(nodeName, isSvgMode); else if (!isNamedNode(dom, nodeName)) {\n            out = createNode(nodeName, isSvgMode);\n            while (dom.firstChild) out.appendChild(dom.firstChild);\n            if (dom.parentNode) dom.parentNode.replaceChild(out, dom);\n            recollectNodeTree(dom);\n        }\n        var fc = out.firstChild, props = out[ATTR_KEY];\n        if (!props) {\n            out[ATTR_KEY] = props = {};\n            for (var a = out.attributes, i = a.length; i--; ) props[a[i].name] = a[i].value;\n        }\n        if (!hydrating && vchildren && 1 === vchildren.length && 'string' == typeof vchildren[0] && fc && fc instanceof Text && !fc.nextSibling) {\n            if (fc.nodeValue != vchildren[0]) fc.nodeValue = vchildren[0];\n        } else if (vchildren && vchildren.length || fc) innerDiffNode(out, vchildren, context, mountAll, !!props.dangerouslySetInnerHTML);\n        diffAttributes(out, vnode.attributes, props);\n        if (ref) (props.ref = ref)(out);\n        isSvgMode = prevSvgMode;\n        return out;\n    }\n    function innerDiffNode(dom, vchildren, context, mountAll, absorb) {\n        var j, c, vchild, child, originalChildren = dom.childNodes, children = [], keyed = {}, keyedLen = 0, min = 0, len = originalChildren.length, childrenLen = 0, vlen = vchildren && vchildren.length;\n        if (len) for (var i = 0; i < len; i++) {\n            var _child = originalChildren[i], props = _child[ATTR_KEY], key = vlen ? (c = _child._component) ? c.__key : props ? props.key : null : null;\n            if (null != key) {\n                keyedLen++;\n                keyed[key] = _child;\n            } else if (hydrating || absorb || props || _child instanceof Text) children[childrenLen++] = _child;\n        }\n        if (vlen) for (var i = 0; i < vlen; i++) {\n            vchild = vchildren[i];\n            child = null;\n            var key = vchild.key;\n            if (null != key) {\n                if (keyedLen && key in keyed) {\n                    child = keyed[key];\n                    keyed[key] = void 0;\n                    keyedLen--;\n                }\n            } else if (!child && min < childrenLen) for (j = min; j < childrenLen; j++) {\n                c = children[j];\n                if (c && isSameNodeType(c, vchild)) {\n                    child = c;\n                    children[j] = void 0;\n                    if (j === childrenLen - 1) childrenLen--;\n                    if (j === min) min++;\n                    break;\n                }\n            }\n            child = idiff(child, vchild, context, mountAll);\n            if (child && child !== dom) if (i >= len) dom.appendChild(child); else if (child !== originalChildren[i]) {\n                if (child === originalChildren[i + 1]) removeNode(originalChildren[i]);\n                dom.insertBefore(child, originalChildren[i] || null);\n            }\n        }\n        if (keyedLen) for (var i in keyed) if (keyed[i]) recollectNodeTree(keyed[i]);\n        while (min <= childrenLen) {\n            child = children[childrenLen--];\n            if (child) recollectNodeTree(child);\n        }\n    }\n    function recollectNodeTree(node, unmountOnly) {\n        var component = node._component;\n        if (component) unmountComponent(component, !unmountOnly); else {\n            if (node[ATTR_KEY] && node[ATTR_KEY].ref) node[ATTR_KEY].ref(null);\n            if (!unmountOnly) collectNode(node);\n            var c;\n            while (c = node.lastChild) recollectNodeTree(c, unmountOnly);\n        }\n    }\n    function diffAttributes(dom, attrs, old) {\n        var name;\n        for (name in old) if (!(attrs && name in attrs) && null != old[name]) setAccessor(dom, name, old[name], old[name] = void 0, isSvgMode);\n        if (attrs) for (name in attrs) if (!('children' === name || 'innerHTML' === name || name in old && attrs[name] === ('value' === name || 'checked' === name ? dom[name] : old[name]))) setAccessor(dom, name, old[name], old[name] = attrs[name], isSvgMode);\n    }\n    function collectComponent(component) {\n        var name = component.constructor.name, list = components[name];\n        if (list) list.push(component); else components[name] = [ component ];\n    }\n    function createComponent(Ctor, props, context) {\n        var inst = new Ctor(props, context), list = components[Ctor.name];\n        Component.call(inst, props, context);\n        if (list) for (var i = list.length; i--; ) if (list[i].constructor === Ctor) {\n            inst.nextBase = list[i].nextBase;\n            list.splice(i, 1);\n            break;\n        }\n        return inst;\n    }\n    function setComponentProps(component, props, opts, context, mountAll) {\n        if (!component._disable) {\n            component._disable = !0;\n            if (component.__ref = props.ref) delete props.ref;\n            if (component.__key = props.key) delete props.key;\n            if (!component.base || mountAll) {\n                if (component.componentWillMount) component.componentWillMount();\n            } else if (component.componentWillReceiveProps) component.componentWillReceiveProps(props, context);\n            if (context && context !== component.context) {\n                if (!component.prevContext) component.prevContext = component.context;\n                component.context = context;\n            }\n            if (!component.prevProps) component.prevProps = component.props;\n            component.props = props;\n            component._disable = !1;\n            if (0 !== opts) if (1 === opts || options.syncComponentUpdates !== !1 || !component.base) renderComponent(component, 1, mountAll); else enqueueRender(component);\n            if (component.__ref) component.__ref(component);\n        }\n    }\n    function renderComponent(component, opts, mountAll, isChild) {\n        if (!component._disable) {\n            var skip, rendered, inst, cbase, props = component.props, state = component.state, context = component.context, previousProps = component.prevProps || props, previousState = component.prevState || state, previousContext = component.prevContext || context, isUpdate = component.base, nextBase = component.nextBase, initialBase = isUpdate || nextBase, initialChildComponent = component._component;\n            if (isUpdate) {\n                component.props = previousProps;\n                component.state = previousState;\n                component.context = previousContext;\n                if (2 !== opts && component.shouldComponentUpdate && component.shouldComponentUpdate(props, state, context) === !1) skip = !0; else if (component.componentWillUpdate) component.componentWillUpdate(props, state, context);\n                component.props = props;\n                component.state = state;\n                component.context = context;\n            }\n            component.prevProps = component.prevState = component.prevContext = component.nextBase = null;\n            component._dirty = !1;\n            if (!skip) {\n                if (component.render) rendered = component.render(props, state, context);\n                if (component.getChildContext) context = extend(clone(context), component.getChildContext());\n                while (isFunctionalComponent(rendered)) rendered = buildFunctionalComponent(rendered, context);\n                var toUnmount, base, childComponent = rendered && rendered.nodeName;\n                if (isFunction(childComponent)) {\n                    var childProps = getNodeProps(rendered);\n                    inst = initialChildComponent;\n                    if (inst && inst.constructor === childComponent && childProps.key == inst.__key) setComponentProps(inst, childProps, 1, context); else {\n                        toUnmount = inst;\n                        inst = createComponent(childComponent, childProps, context);\n                        inst.nextBase = inst.nextBase || nextBase;\n                        inst._parentComponent = component;\n                        component._component = inst;\n                        setComponentProps(inst, childProps, 0, context);\n                        renderComponent(inst, 1, mountAll, !0);\n                    }\n                    base = inst.base;\n                } else {\n                    cbase = initialBase;\n                    toUnmount = initialChildComponent;\n                    if (toUnmount) cbase = component._component = null;\n                    if (initialBase || 1 === opts) {\n                        if (cbase) cbase._component = null;\n                        base = diff(cbase, rendered, context, mountAll || !isUpdate, initialBase && initialBase.parentNode, !0);\n                    }\n                }\n                if (initialBase && base !== initialBase && inst !== initialChildComponent) {\n                    var baseParent = initialBase.parentNode;\n                    if (baseParent && base !== baseParent) {\n                        baseParent.replaceChild(base, initialBase);\n                        if (!toUnmount) {\n                            initialBase._component = null;\n                            recollectNodeTree(initialBase);\n                        }\n                    }\n                }\n                if (toUnmount) unmountComponent(toUnmount, base !== initialBase);\n                component.base = base;\n                if (base && !isChild) {\n                    var componentRef = component, t = component;\n                    while (t = t._parentComponent) (componentRef = t).base = base;\n                    base._component = componentRef;\n                    base._componentConstructor = componentRef.constructor;\n                }\n            }\n            if (!isUpdate || mountAll) mounts.unshift(component); else if (!skip) {\n                if (component.componentDidUpdate) component.componentDidUpdate(previousProps, previousState, previousContext);\n                if (options.afterUpdate) options.afterUpdate(component);\n            }\n            var fn, cb = component._renderCallbacks;\n            if (cb) while (fn = cb.pop()) fn.call(component);\n            if (!diffLevel && !isChild) flushMounts();\n        }\n    }\n    function buildComponentFromVNode(dom, vnode, context, mountAll) {\n        var c = dom && dom._component, originalComponent = c, oldDom = dom, isDirectOwner = c && dom._componentConstructor === vnode.nodeName, isOwner = isDirectOwner, props = getNodeProps(vnode);\n        while (c && !isOwner && (c = c._parentComponent)) isOwner = c.constructor === vnode.nodeName;\n        if (c && isOwner && (!mountAll || c._component)) {\n            setComponentProps(c, props, 3, context, mountAll);\n            dom = c.base;\n        } else {\n            if (originalComponent && !isDirectOwner) {\n                unmountComponent(originalComponent, !0);\n                dom = oldDom = null;\n            }\n            c = createComponent(vnode.nodeName, props, context);\n            if (dom && !c.nextBase) {\n                c.nextBase = dom;\n                oldDom = null;\n            }\n            setComponentProps(c, props, 1, context, mountAll);\n            dom = c.base;\n            if (oldDom && dom !== oldDom) {\n                oldDom._component = null;\n                recollectNodeTree(oldDom);\n            }\n        }\n        return dom;\n    }\n    function unmountComponent(component, remove) {\n        if (options.beforeUnmount) options.beforeUnmount(component);\n        var base = component.base;\n        component._disable = !0;\n        if (component.componentWillUnmount) component.componentWillUnmount();\n        component.base = null;\n        var inner = component._component;\n        if (inner) unmountComponent(inner, remove); else if (base) {\n            if (base[ATTR_KEY] && base[ATTR_KEY].ref) base[ATTR_KEY].ref(null);\n            component.nextBase = base;\n            if (remove) {\n                removeNode(base);\n                collectComponent(component);\n            }\n            var c;\n            while (c = base.lastChild) recollectNodeTree(c, !remove);\n        }\n        if (component.__ref) component.__ref(null);\n        if (component.componentDidUnmount) component.componentDidUnmount();\n    }\n    function Component(props, context) {\n        this._dirty = !0;\n        this.context = context;\n        this.props = props;\n        if (!this.state) this.state = {};\n    }\n    function render(vnode, parent, merge) {\n        return diff(merge, vnode, {}, !1, parent);\n    }\n    var options = {};\n    var stack = [];\n    var EMPTY_CHILDREN = [];\n    var lcCache = {};\n    var toLowerCase = function(s) {\n        return lcCache[s] || (lcCache[s] = s.toLowerCase());\n    };\n    var resolved = 'undefined' != typeof Promise && Promise.resolve();\n    var defer = resolved ? function(f) {\n        resolved.then(f);\n    } : setTimeout;\n    var EMPTY = {};\n    var ATTR_KEY = 'undefined' != typeof Symbol ? Symbol.for('preactattr') : '__preactattr_';\n    var NON_DIMENSION_PROPS = {\n        boxFlex: 1,\n        boxFlexGroup: 1,\n        columnCount: 1,\n        fillOpacity: 1,\n        flex: 1,\n        flexGrow: 1,\n        flexPositive: 1,\n        flexShrink: 1,\n        flexNegative: 1,\n        fontWeight: 1,\n        lineClamp: 1,\n        lineHeight: 1,\n        opacity: 1,\n        order: 1,\n        orphans: 1,\n        strokeOpacity: 1,\n        widows: 1,\n        zIndex: 1,\n        zoom: 1\n    };\n    var NON_BUBBLING_EVENTS = {\n        blur: 1,\n        error: 1,\n        focus: 1,\n        load: 1,\n        resize: 1,\n        scroll: 1\n    };\n    var items = [];\n    var nodes = {};\n    var mounts = [];\n    var diffLevel = 0;\n    var isSvgMode = !1;\n    var hydrating = !1;\n    var components = {};\n    extend(Component.prototype, {\n        linkState: function(key, eventPath) {\n            var c = this._linkedStates || (this._linkedStates = {});\n            return c[key + eventPath] || (c[key + eventPath] = createLinkedState(this, key, eventPath));\n        },\n        setState: function(state, callback) {\n            var s = this.state;\n            if (!this.prevState) this.prevState = clone(s);\n            extend(s, isFunction(state) ? state(s, this.props) : state);\n            if (callback) (this._renderCallbacks = this._renderCallbacks || []).push(callback);\n            enqueueRender(this);\n        },\n        forceUpdate: function() {\n            renderComponent(this, 2);\n        },\n        render: function() {}\n    });\n    exports.h = h;\n    exports.cloneElement = cloneElement;\n    exports.Component = Component;\n    exports.render = render;\n    exports.rerender = rerender;\n    exports.options = options;\n});\n//# sourceMappingURL=preact.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/preact/dist/preact.js\n// module id = EF6w\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = b+29\n// module chunks = 0","// eslint-disable-next-line no-unused-vars\n/** @jsx h */\nimport { render, h } from 'preact'\n\nlet root\nfunction run () {\n  const Root = require('./App').default\n  root = render(<Root test={'foo'}/>, document.querySelector('#demo'), root)\n}\n\nrun()\n\nif (module.hot) {\n  // Whenever a new version of App.js is available\n  module.hot.accept('./App', function () {\n    // Require the new version and render it instead\n    run()\n  })\n}\n\n\n\n// WEBPACK FOOTER //\n// ./demo/src/index.js","/** @jsx h */\nimport './style.css'\nimport { render, h, Component } from 'preact'\nimport { Provider, connect } from 'preact-smitty'\nimport { createStore } from '../../src'\nimport source from 'raw-loader!./App.js'\nimport localforage from 'localforage'\n\nlocalforage.config({ name: 'smitty_photo_booth' })\n\nconst pp = obj => JSON.stringify(obj, null, 2)\nconst getId = () => new Date().toString()\n\nconst store = createStore({\n  camera: {\n    recording: false,\n    stream: new window.MediaStream(),\n    images: []\n  },\n  ui: {\n    selectedImageId: null\n  }\n})\n\nstore.createActions({\n  startMediaStream: constraints =>\n    async store => {\n      try {\n        const stream = await navigator.mediaDevices.getUserMedia(constraints)\n        store.actions.mediaStreamSuccess(stream)\n      } catch (err) {\n        store.actions.mediaStreamError(err)\n      }\n    },\n  mediaStreamSuccess: 'camera/STREAM_SUCCESS',\n  mediaStreamError: 'camera/STREAM_ERROR',\n  addImages: 'camera/ADD_IMAGES',\n  saveImage: url =>\n    store => {\n      const id = getId()\n      const image = { id, url }\n      store.actions.addImages([image])\n\n      localforage\n        .getItem('images')\n        .then(images => {\n          images.push(image)\n          localforage.setItem('images', images)\n        })\n        .catch(err => console.log('Could not save image to db', err))\n    },\n  selectImage: (id) => store => {\n    store.actions.setSelectedImageById(id)\n    window.history.pushState({}, '', id || '/')\n  },\n  setSelectedImageById: 'ui/SELECT_IMAGE'\n})\n\nstore.handleActions({\n  [store.actions.mediaStreamSuccess]: (state, stream) => {\n    state.camera.stream = stream\n  },\n  [store.actions.mediaStreamError]: (state, error) => {\n    state.camera.streamError = error\n  },\n  [store.actions.addImages]: (state, images) => {\n    state.camera.images = state.camera.images.concat(images)\n  },\n  [store.actions.setSelectedImageById]: (state, imageId) => {\n    state.ui.selectedImageId = imageId\n  }\n})\n\nlocalforage.getItem('images').then(images => {\n  if (images) {\n    store.actions.addImages(images)\n  } else {\n    localforage.setItem('images', [])\n  }\n})\n\n\nif (window.location.pathname !== '/') {\n  store.actions.setSelectedImageById(decodeURI(window.location.pathname).split('/')[1])\n}\n\nwindow.onpopstate = function (event) {\n  store.actions.setSelectedImageById(decodeURI(window.location.pathname).split('/')[1])\n}\n\nconst Camera = connect(state => ({\n  stream: state.camera.stream,\n  streamError: state.camera.streamError\n}))(\n  class Camera extends Component {\n    video = null;\n    canvas = null;\n\n    componentDidMount () {\n      this.context.store.actions.startMediaStream({\n        audio: false,\n        video: true\n      })\n    }\n\n    render ({ streamError }) {\n      return (\n        <div\n          style={{\n            paddingTop: 16,\n            paddingRight: 16,\n            paddingBottom: 16,\n            paddingLeft: 16\n          }}\n        >\n          <h3\n            style={{\n              height: streamError ? 24 : 0,\n              lineHeight: '1.2',\n              marginBottom: 16,\n              textAlign: 'center',\n              color: '#ff6b6b',\n              opacity: streamError ? 1 : 0,\n              transition: 'all 250ms ease-in-out'\n            }}\n          >\n            {streamError ? streamError.name : ''}\n          </h3>\n          <video\n            ref={node => {\n              this.video = node\n            }}\n            style={{\n              width: '100%',\n              maxHeight: 'calc(50vh - 16px)',\n              background: '#212529',\n              cursor: 'pointer'\n            }}\n            src={\n              window.URL\n                ? window.URL.createObjectURL(this.props.stream)\n                : this.props.stream\n            }\n            autoplay\n            muted\n            onClick={this.handleClick}\n          />\n          <canvas\n            ref={node => {\n              this.canvas = node\n            }}\n            style={{ display: 'none' }}\n          />\n          <div\n            style={{\n              display: 'flex',\n              alignItems: 'center',\n              justifyContent: 'center',\n              width: '100%',\n              marginTop: 16,\n              marginBottom: 16\n            }}\n          >\n            <button\n              style={{\n                paddingTop: 8,\n                paddingRight: 16,\n                paddingBottom: 8,\n                paddingLeft: 16,\n                margin: '0 auto',\n                fontSize: 20,\n                lineHeight: '1.6',\n                color: '#adb5bd',\n                background: '#343a40',\n                border: 'none',\n                outline: 'none',\n                boxShadow: 'none',\n                borderRadius: 5,\n                cursor: 'pointer',\n                opacity: streamError ? 0 : 1,\n                transition: 'all 250ms ease-in-out'\n              }}\n              disabled={streamError}\n              type={'button'}\n              onClick={this.handleClick}\n            >\n              Take Picture\n            </button>\n          </div>\n\n        </div>\n      )\n    }\n\n    handleClick = () => {\n      const canvas = this.canvas\n      const ctx = canvas.getContext('2d')\n      const width = this.video.videoWidth\n      const height = this.video.videoHeight\n      canvas.width = width\n      canvas.height = height\n      ctx.fillRect(0, 0, width, height)\n      ctx.drawImage(this.video, 0, 0, width, height)\n\n      this.context.store.actions.saveImage(canvas.toDataURL('image/webp'))\n    };\n  }\n)\n\nconst ImageList = connect(state => ({\n  images: state.camera.images,\n  selectedImageId: state.ui.selectedImageId\n}))(function ImageList ({ images, selectedImageId }, { store }) {\n  return (\n    <div\n      style={{\n        display: 'flex',\n        flexFlow: 'wrap'\n      }}\n    >\n      {images.map((image, i) => {\n        return (\n          <Image\n            key={image.id}\n            image={image}\n            index={i}\n            selected={image.id === selectedImageId}\n            onClick={() => {\n              store.actions.selectImage(image.id === selectedImageId ? null : image.id)\n            }}\n          />\n        )\n      })}\n    </div>\n  )\n})\n\nfunction Image ({ image, index, onClick, selected }) {\n  const wrapperStyles = selected\n    ? {\n      position: 'fixed',\n      top: 0,\n      left: 0,\n      right: 0,\n      bottom: 0,\n      width: '100%',\n      height: '100%',\n      display: 'flex',\n      alignItems: 'center',\n      justifyContent: 'center',\n      background: '#f8f9fa',\n      zIndex: 10\n    }\n    : {\n      position: 'relative',\n      flex: '0 1 auto',\n      width: 'calc(33% - 4px)',\n      order: index * -1,\n      paddingTop: 2,\n      paddingRight: 2,\n      paddingBottom: 0,\n      paddingLeft: 2\n    }\n\n  const imgStyles = selected ? { width: '90%', maxHeight: '90%', borderRadius: 8 } : { width: '100%', borderRadius: 4 }\n\n  return (\n    <a\n      style={wrapperStyles}\n      href={image.url}\n      target={'_blank'}\n      onClick={e => {\n        e.preventDefault()\n        onClick()\n      }}\n    >\n      <img src={image.url} style={imgStyles} />\n    </a>\n  )\n}\n\nfunction GithubRibbon () {\n  return (\n    <iframe\n      src='https://ghbtns.com/github-btn.html?user=tkh44&amp;repo=smitty&amp;type=star&amp;count=true&amp;size=large'\n      frameborder='0'\n      scrolling='0'\n      width='160px'\n      height='30px'\n      style={{ marginLeft: 'auto' }}\n    />\n  )\n}\n\nconst App = connect(state => state)(props => (\n  <div style={{ display: 'flex' }}>\n    <div\n      style={{\n        flex: '1 0 50%',\n        height: '100vh',\n        background: '#212529',\n        overflow: 'auto',\n        WebkitOverflowScrolling: 'touch',\n        background: props.camera.streamError ? '#f8f9fa' : '#212529',\n        cursor: 'pointer',\n        transition: 'all 250ms ease-in-out'\n      }}\n    >\n      <Camera />\n    </div>\n\n    <div\n      style={{\n        flex: '1 0 50%',\n        height: '100vh',\n        background: '#f8f9fa',\n        borderLeft: '1px solid #dee2e6',\n        overflow: 'auto',\n        WebkitOverflowScrolling: 'touch'\n      }}\n    >\n      <div\n        style={{\n          display: 'flex',\n          alignItems: 'center',\n          borderBottom: '1px solid #dee2e6',\n          paddingRight: 8,\n          paddingLeft: 8\n        }}\n      >\n        <h2>Smitty Photo Booth Demo</h2>\n        <a\n          href={'https://github.com/tkh44/smitty/tree/master/demo/src'}\n          style={{ fontSize: '1rem', color: '#329af0', marginLeft: 8 }}\n          target={'_blank'}\n        >\n          source\n        </a>\n        <GithubRibbon />\n      </div>\n      <ImageList />\n    </div>\n  </div>\n))\n\nconst Root = function (props) {\n  return (\n    <Provider store={store}>\n      <App />\n    </Provider>\n  )\n}\n\nexport default Root\n\n\n\n// WEBPACK FOOTER //\n// ./demo/src/App.js","import mitt from 'mitt'\n\nfunction Store (initialState) {\n  let _state = initialState\n  this.actions = {}\n  this.events = mitt()\n  this.on = this.events.on\n  this.off = this.events.off\n  this.emit = this.emit.bind(this)\n  this.handleActions = this.handleActions.bind(this)\n\n  Object.defineProperty(this, 'state', {\n    get: function () {\n      return _state\n    },\n    set: function (value) {\n      _state = value\n    }\n  })\n}\n\nObject.assign(Store.prototype, {\n  emit (type, payload) {\n    if (typeof type === 'function') return type(this)\n    this.events.emit(type, payload)\n  },\n\n  createActions (actionMap) {\n    for (let creatorName in actionMap) {\n      const type = actionMap[creatorName]\n      let actionCreator\n      if (typeof type === 'function') {\n        actionCreator = payload => this.emit(type(payload))\n      } else {\n        actionCreator = payload => this.emit(type, payload)\n        actionCreator.toString = () => type.toString()\n      }\n      this.actions[creatorName] = actionCreator\n    }\n  },\n\n  handleActions (handlerMap) {\n    for (let type in handlerMap) {\n      let handler = (eventType, e) => {\n        if (eventType.substring(0, 8) === '$$store:') return\n        this.state = handlerMap[type](this.state, e, eventType) || this.state\n        this.events.emit('$$store:state:change', this.state)\n      }\n      if (type !== '*') {\n        handler = handler.bind(null, type)\n      }\n      this.events.on(type, handler)\n    }\n  }\n})\n\nexport function createStore (initialState) {\n  return new Store(initialState)\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","function n(n){return n=n||Object.create(null),{on:function(t,o){(n[t]||(n[t]=[])).push(o)},off:function(t,o){var u=n[t]||(n[t]=[]);u.splice(u.indexOf(o)>>>0,1)},emit:function(t,o){(n[t]||[]).map(function(n){n(o)}),(n[\"*\"]||[]).map(function(n){n(t,o)})}}}module.exports=n;\n//# sourceMappingURL=mitt.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/mitt/dist/mitt.js\n// module id = tNdy\n// module chunks = 0"],"sourceRoot":""}